// Code generated from JetRule.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // JetRule

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type JetRuleParser struct {
	*antlr.BaseParser
}

var JetRuleParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func jetruleParserInit() {
	staticData := &JetRuleParserStaticData
	staticData.LiteralNames = []string{
		"", "'{'", "'}'", "','", "'['", "']'", "'as'", "'.'", "':'", "'->'",
		"'('", "')'", "'?'", "'@JetCompilerDirective'", "'class'", "'$base_classes'",
		"'$as_table'", "'$data_properties'", "'array of'", "'$grouping_properties'",
		"'main'", "'jetstore_config'", "'$max_looping'", "'$max_rule_exec'",
		"'$input_types'", "'rule_sequence'", "'$main_rule_sets'", "'triple'",
		"'int'", "'uint'", "'long'", "'ulong'", "'double'", "'text'", "'date'",
		"'datetime'", "'bool'", "'resource'", "'volatile_resource'", "'create_uuid_resource()'",
		"'lookup_table'", "'$table_name'", "'$csv_file'", "'$key'", "'$columns'",
		"'true'", "'false'", "'null'", "'not'", "'toText'", "'=='", "'<'", "'<='",
		"'>'", "'>='", "'!='", "'r?'", "'+'", "'-'", "'*'", "'/'", "'or'", "'and'",
		"';'", "'='",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "JetCompilerDirective",
		"CLASS", "BaseClasses", "AsTable", "DataProperties", "ARRAY", "GroupingProperties",
		"MAIN", "JETSCONFIG", "MaxLooping", "MaxRuleExec", "InputType", "RULESEQ",
		"MainRuleSets", "TRIPLE", "Int32Type", "UInt32Type", "Int64Type", "UInt64Type",
		"DoubleType", "StringType", "DateType", "DatetimeType", "BoolType",
		"ResourceType", "VolatileResourceType", "CreateUUIDResource", "LookupTable",
		"TableName", "CSVFileName", "Key", "Columns", "TRUE", "FALSE", "NULL",
		"NOT", "TOTEXT", "EQ", "LT", "LE", "GT", "GE", "NE", "REGEX2", "PLUS",
		"MINUS", "MUL", "DIV", "OR", "AND", "SEMICOLON", "ASSIGN", "Identifier",
		"DIGITS", "STRING", "COMMENT", "WS",
	}
	staticData.RuleNames = []string{
		"jetrule", "statement", "jetCompilerDirectiveStmt", "defineJetStoreConfigStmt",
		"jetstoreConfig", "jetstoreConfigSeq", "jetstoreConfigItem", "defineClassStmt",
		"classStmt", "subClassOfStmt", "dataPropertyDefinitions", "dataPropertyType",
		"groupingPropertyStmt", "asTableStmt", "asTableFlag", "defineRuleSeqStmt",
		"ruleSetSeq", "ruleSetDefinitions", "defineLiteralStmt", "int32LiteralStmt",
		"uInt32LiteralStmt", "int64LiteralStmt", "uInt64LiteralStmt", "doubleLiteralStmt",
		"stringLiteralStmt", "dateLiteralStmt", "datetimeLiteralStmt", "booleanLiteralStmt",
		"intExpr", "uintExpr", "doubleExpr", "declIdentifier", "defineResourceStmt",
		"namedResourceStmt", "volatileResourceStmt", "resourceValue", "lookupTableStmt",
		"csvLocation", "stringList", "stringSeq", "columnDefSeq", "columnDefinitions",
		"jetRuleStmt", "ruleProperties", "propertyValue", "antecedent", "consequent",
		"atom", "objectAtom", "keywords", "exprTerm", "binaryOp", "unaryOp",
		"tripleStmt",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 69, 817, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 1, 0, 5, 0, 110, 8, 0, 10, 0, 12, 0, 113, 9, 0, 1, 0,
		1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,
		127, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 5, 3,
		138, 8, 3, 10, 3, 12, 3, 141, 9, 3, 1, 3, 1, 3, 5, 3, 145, 8, 3, 10, 3,
		12, 3, 148, 9, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 5, 5,
		158, 8, 5, 10, 5, 12, 5, 161, 9, 5, 1, 5, 5, 5, 164, 8, 5, 10, 5, 12, 5,
		167, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		5, 6, 179, 8, 6, 10, 6, 12, 6, 182, 9, 6, 1, 6, 1, 6, 1, 6, 5, 6, 187,
		8, 6, 10, 6, 12, 6, 190, 9, 6, 1, 6, 5, 6, 193, 8, 6, 10, 6, 12, 6, 196,
		9, 6, 1, 6, 5, 6, 199, 8, 6, 10, 6, 12, 6, 202, 9, 6, 1, 6, 1, 6, 3, 6,
		206, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 212, 8, 7, 10, 7, 12, 7, 215,
		9, 7, 1, 7, 1, 7, 1, 7, 5, 7, 220, 8, 7, 10, 7, 12, 7, 223, 9, 7, 1, 7,
		5, 7, 226, 8, 7, 10, 7, 12, 7, 229, 9, 7, 1, 7, 5, 7, 232, 8, 7, 10, 7,
		12, 7, 235, 9, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 244,
		8, 8, 10, 8, 12, 8, 247, 9, 8, 1, 8, 1, 8, 1, 8, 5, 8, 252, 8, 8, 10, 8,
		12, 8, 255, 9, 8, 1, 8, 5, 8, 258, 8, 8, 10, 8, 12, 8, 261, 9, 8, 1, 8,
		5, 8, 264, 8, 8, 10, 8, 12, 8, 267, 9, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 5, 8, 275, 8, 8, 10, 8, 12, 8, 278, 9, 8, 1, 8, 1, 8, 1, 8, 5, 8,
		283, 8, 8, 10, 8, 12, 8, 286, 9, 8, 1, 8, 5, 8, 289, 8, 8, 10, 8, 12, 8,
		292, 9, 8, 1, 8, 5, 8, 295, 8, 8, 10, 8, 12, 8, 298, 9, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 306, 8, 8, 10, 8, 12, 8, 309, 9, 8, 1, 8,
		1, 8, 1, 8, 5, 8, 314, 8, 8, 10, 8, 12, 8, 317, 9, 8, 1, 8, 5, 8, 320,
		8, 8, 10, 8, 12, 8, 323, 9, 8, 1, 8, 5, 8, 326, 8, 8, 10, 8, 12, 8, 329,
		9, 8, 1, 8, 1, 8, 1, 8, 3, 8, 334, 8, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10,
		3, 10, 341, 8, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 359,
		8, 15, 10, 15, 12, 15, 362, 9, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 368,
		8, 15, 10, 15, 12, 15, 371, 9, 15, 1, 15, 1, 15, 5, 15, 375, 8, 15, 10,
		15, 12, 15, 378, 9, 15, 1, 15, 1, 15, 3, 15, 382, 8, 15, 1, 15, 5, 15,
		385, 8, 15, 10, 15, 12, 15, 388, 9, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1,
		16, 1, 16, 5, 16, 396, 8, 16, 10, 16, 12, 16, 399, 9, 16, 1, 16, 5, 16,
		402, 8, 16, 10, 16, 12, 16, 405, 9, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 418, 8, 18, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22,
		1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26,
		1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 479, 8, 28, 1, 29, 1, 29,
		1, 29, 3, 29, 484, 8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 493, 8, 30, 3, 30, 495, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 3, 31, 504, 8, 31, 1, 32, 1, 32, 3, 32, 508, 8, 32, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 1, 35, 1, 35, 1, 35, 3, 35, 525, 8, 35, 1, 36, 1, 36, 1, 36, 1,
		36, 5, 36, 531, 8, 36, 10, 36, 12, 36, 534, 9, 36, 1, 36, 1, 36, 5, 36,
		538, 8, 36, 10, 36, 12, 36, 541, 9, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1,
		36, 5, 36, 548, 8, 36, 10, 36, 12, 36, 551, 9, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 5, 36, 557, 8, 36, 10, 36, 12, 36, 560, 9, 36, 1, 36, 1, 36, 5,
		36, 564, 8, 36, 10, 36, 12, 36, 567, 9, 36, 1, 36, 1, 36, 3, 36, 571, 8,
		36, 1, 36, 5, 36, 574, 8, 36, 10, 36, 12, 36, 577, 9, 36, 1, 36, 1, 36,
		1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3,
		37, 591, 8, 37, 1, 38, 1, 38, 3, 38, 595, 8, 38, 1, 38, 1, 38, 1, 39, 1,
		39, 1, 39, 5, 39, 602, 8, 39, 10, 39, 12, 39, 605, 9, 39, 1, 40, 1, 40,
		1, 40, 5, 40, 610, 8, 40, 10, 40, 12, 40, 613, 9, 40, 1, 40, 5, 40, 616,
		8, 40, 10, 40, 12, 40, 619, 9, 40, 1, 41, 1, 41, 1, 41, 3, 41, 624, 8,
		41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 5, 42, 631, 8, 42, 10, 42, 12, 42,
		634, 9, 42, 1, 42, 1, 42, 1, 42, 5, 42, 639, 8, 42, 10, 42, 12, 42, 642,
		9, 42, 1, 42, 1, 42, 5, 42, 646, 8, 42, 10, 42, 12, 42, 649, 9, 42, 4,
		42, 651, 8, 42, 11, 42, 12, 42, 652, 1, 42, 1, 42, 5, 42, 657, 8, 42, 10,
		42, 12, 42, 660, 9, 42, 1, 42, 1, 42, 5, 42, 664, 8, 42, 10, 42, 12, 42,
		667, 9, 42, 4, 42, 669, 8, 42, 11, 42, 12, 42, 670, 1, 42, 1, 42, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 684, 8,
		44, 1, 45, 3, 45, 687, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 695, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 701, 8, 45, 3, 45,
		703, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 711, 8, 46,
		1, 47, 1, 47, 1, 47, 3, 47, 716, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 763,
		8, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 792, 8, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 5, 50, 798, 8, 50, 10, 50, 12, 50, 801, 9, 50,
		1, 51, 1, 51, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 0, 1, 100, 54, 0, 2, 4, 6, 8, 10, 12, 14,
		16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
		52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
		88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 0, 6, 1, 0, 20, 21, 1, 0, 28,
		37, 1, 0, 45, 46, 1, 0, 45, 47, 2, 0, 50, 62, 65, 65, 2, 0, 48, 49, 65,
		65, 875, 0, 111, 1, 0, 0, 0, 2, 126, 1, 0, 0, 0, 4, 128, 1, 0, 0, 0, 6,
		134, 1, 0, 0, 0, 8, 152, 1, 0, 0, 0, 10, 154, 1, 0, 0, 0, 12, 205, 1, 0,
		0, 0, 14, 207, 1, 0, 0, 0, 16, 333, 1, 0, 0, 0, 18, 335, 1, 0, 0, 0, 20,
		337, 1, 0, 0, 0, 22, 344, 1, 0, 0, 0, 24, 346, 1, 0, 0, 0, 26, 348, 1,
		0, 0, 0, 28, 352, 1, 0, 0, 0, 30, 354, 1, 0, 0, 0, 32, 392, 1, 0, 0, 0,
		34, 406, 1, 0, 0, 0, 36, 417, 1, 0, 0, 0, 38, 419, 1, 0, 0, 0, 40, 425,
		1, 0, 0, 0, 42, 431, 1, 0, 0, 0, 44, 437, 1, 0, 0, 0, 46, 443, 1, 0, 0,
		0, 48, 449, 1, 0, 0, 0, 50, 455, 1, 0, 0, 0, 52, 461, 1, 0, 0, 0, 54, 467,
		1, 0, 0, 0, 56, 478, 1, 0, 0, 0, 58, 483, 1, 0, 0, 0, 60, 494, 1, 0, 0,
		0, 62, 503, 1, 0, 0, 0, 64, 507, 1, 0, 0, 0, 66, 509, 1, 0, 0, 0, 68, 515,
		1, 0, 0, 0, 70, 524, 1, 0, 0, 0, 72, 526, 1, 0, 0, 0, 74, 590, 1, 0, 0,
		0, 76, 592, 1, 0, 0, 0, 78, 598, 1, 0, 0, 0, 80, 606, 1, 0, 0, 0, 82, 620,
		1, 0, 0, 0, 84, 627, 1, 0, 0, 0, 86, 674, 1, 0, 0, 0, 88, 683, 1, 0, 0,
		0, 90, 686, 1, 0, 0, 0, 92, 704, 1, 0, 0, 0, 94, 715, 1, 0, 0, 0, 96, 762,
		1, 0, 0, 0, 98, 764, 1, 0, 0, 0, 100, 791, 1, 0, 0, 0, 102, 802, 1, 0,
		0, 0, 104, 804, 1, 0, 0, 0, 106, 806, 1, 0, 0, 0, 108, 110, 3, 2, 1, 0,
		109, 108, 1, 0, 0, 0, 110, 113, 1, 0, 0, 0, 111, 109, 1, 0, 0, 0, 111,
		112, 1, 0, 0, 0, 112, 114, 1, 0, 0, 0, 113, 111, 1, 0, 0, 0, 114, 115,
		5, 0, 0, 1, 115, 1, 1, 0, 0, 0, 116, 127, 3, 4, 2, 0, 117, 127, 3, 6, 3,
		0, 118, 127, 3, 36, 18, 0, 119, 127, 3, 14, 7, 0, 120, 127, 3, 30, 15,
		0, 121, 127, 3, 64, 32, 0, 122, 127, 3, 72, 36, 0, 123, 127, 3, 84, 42,
		0, 124, 127, 3, 106, 53, 0, 125, 127, 5, 68, 0, 0, 126, 116, 1, 0, 0, 0,
		126, 117, 1, 0, 0, 0, 126, 118, 1, 0, 0, 0, 126, 119, 1, 0, 0, 0, 126,
		120, 1, 0, 0, 0, 126, 121, 1, 0, 0, 0, 126, 122, 1, 0, 0, 0, 126, 123,
		1, 0, 0, 0, 126, 124, 1, 0, 0, 0, 126, 125, 1, 0, 0, 0, 127, 3, 1, 0, 0,
		0, 128, 129, 5, 13, 0, 0, 129, 130, 3, 62, 31, 0, 130, 131, 5, 64, 0, 0,
		131, 132, 5, 67, 0, 0, 132, 133, 5, 63, 0, 0, 133, 5, 1, 0, 0, 0, 134,
		135, 3, 8, 4, 0, 135, 139, 5, 1, 0, 0, 136, 138, 5, 68, 0, 0, 137, 136,
		1, 0, 0, 0, 138, 141, 1, 0, 0, 0, 139, 137, 1, 0, 0, 0, 139, 140, 1, 0,
		0, 0, 140, 142, 1, 0, 0, 0, 141, 139, 1, 0, 0, 0, 142, 146, 3, 10, 5, 0,
		143, 145, 5, 68, 0, 0, 144, 143, 1, 0, 0, 0, 145, 148, 1, 0, 0, 0, 146,
		144, 1, 0, 0, 0, 146, 147, 1, 0, 0, 0, 147, 149, 1, 0, 0, 0, 148, 146,
		1, 0, 0, 0, 149, 150, 5, 2, 0, 0, 150, 151, 5, 63, 0, 0, 151, 7, 1, 0,
		0, 0, 152, 153, 7, 0, 0, 0, 153, 9, 1, 0, 0, 0, 154, 165, 3, 12, 6, 0,
		155, 159, 5, 3, 0, 0, 156, 158, 5, 68, 0, 0, 157, 156, 1, 0, 0, 0, 158,
		161, 1, 0, 0, 0, 159, 157, 1, 0, 0, 0, 159, 160, 1, 0, 0, 0, 160, 162,
		1, 0, 0, 0, 161, 159, 1, 0, 0, 0, 162, 164, 3, 12, 6, 0, 163, 155, 1, 0,
		0, 0, 164, 167, 1, 0, 0, 0, 165, 163, 1, 0, 0, 0, 165, 166, 1, 0, 0, 0,
		166, 11, 1, 0, 0, 0, 167, 165, 1, 0, 0, 0, 168, 169, 5, 22, 0, 0, 169,
		170, 5, 64, 0, 0, 170, 206, 3, 58, 29, 0, 171, 172, 5, 23, 0, 0, 172, 173,
		5, 64, 0, 0, 173, 206, 3, 58, 29, 0, 174, 175, 5, 24, 0, 0, 175, 176, 5,
		64, 0, 0, 176, 180, 5, 4, 0, 0, 177, 179, 5, 68, 0, 0, 178, 177, 1, 0,
		0, 0, 179, 182, 1, 0, 0, 0, 180, 178, 1, 0, 0, 0, 180, 181, 1, 0, 0, 0,
		181, 183, 1, 0, 0, 0, 182, 180, 1, 0, 0, 0, 183, 194, 3, 62, 31, 0, 184,
		188, 5, 3, 0, 0, 185, 187, 5, 68, 0, 0, 186, 185, 1, 0, 0, 0, 187, 190,
		1, 0, 0, 0, 188, 186, 1, 0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 191, 1, 0,
		0, 0, 190, 188, 1, 0, 0, 0, 191, 193, 3, 62, 31, 0, 192, 184, 1, 0, 0,
		0, 193, 196, 1, 0, 0, 0, 194, 192, 1, 0, 0, 0, 194, 195, 1, 0, 0, 0, 195,
		200, 1, 0, 0, 0, 196, 194, 1, 0, 0, 0, 197, 199, 5, 68, 0, 0, 198, 197,
		1, 0, 0, 0, 199, 202, 1, 0, 0, 0, 200, 198, 1, 0, 0, 0, 200, 201, 1, 0,
		0, 0, 201, 203, 1, 0, 0, 0, 202, 200, 1, 0, 0, 0, 203, 204, 5, 5, 0, 0,
		204, 206, 1, 0, 0, 0, 205, 168, 1, 0, 0, 0, 205, 171, 1, 0, 0, 0, 205,
		174, 1, 0, 0, 0, 206, 13, 1, 0, 0, 0, 207, 208, 5, 14, 0, 0, 208, 209,
		3, 62, 31, 0, 209, 213, 5, 1, 0, 0, 210, 212, 5, 68, 0, 0, 211, 210, 1,
		0, 0, 0, 212, 215, 1, 0, 0, 0, 213, 211, 1, 0, 0, 0, 213, 214, 1, 0, 0,
		0, 214, 216, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 216, 227, 3, 16, 8, 0, 217,
		221, 5, 3, 0, 0, 218, 220, 5, 68, 0, 0, 219, 218, 1, 0, 0, 0, 220, 223,
		1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 221, 222, 1, 0, 0, 0, 222, 224, 1, 0,
		0, 0, 223, 221, 1, 0, 0, 0, 224, 226, 3, 16, 8, 0, 225, 217, 1, 0, 0, 0,
		226, 229, 1, 0, 0, 0, 227, 225, 1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228,
		233, 1, 0, 0, 0, 229, 227, 1, 0, 0, 0, 230, 232, 5, 68, 0, 0, 231, 230,
		1, 0, 0, 0, 232, 235, 1, 0, 0, 0, 233, 231, 1, 0, 0, 0, 233, 234, 1, 0,
		0, 0, 234, 236, 1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 236, 237, 5, 2, 0, 0,
		237, 238, 5, 63, 0, 0, 238, 15, 1, 0, 0, 0, 239, 240, 5, 15, 0, 0, 240,
		241, 5, 64, 0, 0, 241, 245, 5, 4, 0, 0, 242, 244, 5, 68, 0, 0, 243, 242,
		1, 0, 0, 0, 244, 247, 1, 0, 0, 0, 245, 243, 1, 0, 0, 0, 245, 246, 1, 0,
		0, 0, 246, 248, 1, 0, 0, 0, 247, 245, 1, 0, 0, 0, 248, 259, 3, 18, 9, 0,
		249, 253, 5, 3, 0, 0, 250, 252, 5, 68, 0, 0, 251, 250, 1, 0, 0, 0, 252,
		255, 1, 0, 0, 0, 253, 251, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 256,
		1, 0, 0, 0, 255, 253, 1, 0, 0, 0, 256, 258, 3, 18, 9, 0, 257, 249, 1, 0,
		0, 0, 258, 261, 1, 0, 0, 0, 259, 257, 1, 0, 0, 0, 259, 260, 1, 0, 0, 0,
		260, 265, 1, 0, 0, 0, 261, 259, 1, 0, 0, 0, 262, 264, 5, 68, 0, 0, 263,
		262, 1, 0, 0, 0, 264, 267, 1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 265, 266,
		1, 0, 0, 0, 266, 268, 1, 0, 0, 0, 267, 265, 1, 0, 0, 0, 268, 269, 5, 5,
		0, 0, 269, 334, 1, 0, 0, 0, 270, 271, 5, 17, 0, 0, 271, 272, 5, 64, 0,
		0, 272, 276, 5, 4, 0, 0, 273, 275, 5, 68, 0, 0, 274, 273, 1, 0, 0, 0, 275,
		278, 1, 0, 0, 0, 276, 274, 1, 0, 0, 0, 276, 277, 1, 0, 0, 0, 277, 279,
		1, 0, 0, 0, 278, 276, 1, 0, 0, 0, 279, 290, 3, 20, 10, 0, 280, 284, 5,
		3, 0, 0, 281, 283, 5, 68, 0, 0, 282, 281, 1, 0, 0, 0, 283, 286, 1, 0, 0,
		0, 284, 282, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 287, 1, 0, 0, 0, 286,
		284, 1, 0, 0, 0, 287, 289, 3, 20, 10, 0, 288, 280, 1, 0, 0, 0, 289, 292,
		1, 0, 0, 0, 290, 288, 1, 0, 0, 0, 290, 291, 1, 0, 0, 0, 291, 296, 1, 0,
		0, 0, 292, 290, 1, 0, 0, 0, 293, 295, 5, 68, 0, 0, 294, 293, 1, 0, 0, 0,
		295, 298, 1, 0, 0, 0, 296, 294, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297,
		299, 1, 0, 0, 0, 298, 296, 1, 0, 0, 0, 299, 300, 5, 5, 0, 0, 300, 334,
		1, 0, 0, 0, 301, 302, 5, 19, 0, 0, 302, 303, 5, 64, 0, 0, 303, 307, 5,
		4, 0, 0, 304, 306, 5, 68, 0, 0, 305, 304, 1, 0, 0, 0, 306, 309, 1, 0, 0,
		0, 307, 305, 1, 0, 0, 0, 307, 308, 1, 0, 0, 0, 308, 310, 1, 0, 0, 0, 309,
		307, 1, 0, 0, 0, 310, 321, 3, 24, 12, 0, 311, 315, 5, 3, 0, 0, 312, 314,
		5, 68, 0, 0, 313, 312, 1, 0, 0, 0, 314, 317, 1, 0, 0, 0, 315, 313, 1, 0,
		0, 0, 315, 316, 1, 0, 0, 0, 316, 318, 1, 0, 0, 0, 317, 315, 1, 0, 0, 0,
		318, 320, 3, 24, 12, 0, 319, 311, 1, 0, 0, 0, 320, 323, 1, 0, 0, 0, 321,
		319, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 327, 1, 0, 0, 0, 323, 321,
		1, 0, 0, 0, 324, 326, 5, 68, 0, 0, 325, 324, 1, 0, 0, 0, 326, 329, 1, 0,
		0, 0, 327, 325, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 330, 1, 0, 0, 0,
		329, 327, 1, 0, 0, 0, 330, 331, 5, 5, 0, 0, 331, 334, 1, 0, 0, 0, 332,
		334, 3, 26, 13, 0, 333, 239, 1, 0, 0, 0, 333, 270, 1, 0, 0, 0, 333, 301,
		1, 0, 0, 0, 333, 332, 1, 0, 0, 0, 334, 17, 1, 0, 0, 0, 335, 336, 3, 62,
		31, 0, 336, 19, 1, 0, 0, 0, 337, 338, 3, 62, 31, 0, 338, 340, 5, 6, 0,
		0, 339, 341, 5, 18, 0, 0, 340, 339, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341,
		342, 1, 0, 0, 0, 342, 343, 3, 22, 11, 0, 343, 21, 1, 0, 0, 0, 344, 345,
		7, 1, 0, 0, 345, 23, 1, 0, 0, 0, 346, 347, 3, 62, 31, 0, 347, 25, 1, 0,
		0, 0, 348, 349, 5, 16, 0, 0, 349, 350, 5, 64, 0, 0, 350, 351, 3, 28, 14,
		0, 351, 27, 1, 0, 0, 0, 352, 353, 7, 2, 0, 0, 353, 29, 1, 0, 0, 0, 354,
		355, 5, 25, 0, 0, 355, 356, 5, 65, 0, 0, 356, 360, 5, 1, 0, 0, 357, 359,
		5, 68, 0, 0, 358, 357, 1, 0, 0, 0, 359, 362, 1, 0, 0, 0, 360, 358, 1, 0,
		0, 0, 360, 361, 1, 0, 0, 0, 361, 363, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0,
		363, 364, 5, 26, 0, 0, 364, 365, 5, 64, 0, 0, 365, 369, 5, 4, 0, 0, 366,
		368, 5, 68, 0, 0, 367, 366, 1, 0, 0, 0, 368, 371, 1, 0, 0, 0, 369, 367,
		1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370, 372, 1, 0, 0, 0, 371, 369, 1, 0,
		0, 0, 372, 376, 3, 32, 16, 0, 373, 375, 5, 68, 0, 0, 374, 373, 1, 0, 0,
		0, 375, 378, 1, 0, 0, 0, 376, 374, 1, 0, 0, 0, 376, 377, 1, 0, 0, 0, 377,
		379, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 379, 381, 5, 5, 0, 0, 380, 382,
		5, 3, 0, 0, 381, 380, 1, 0, 0, 0, 381, 382, 1, 0, 0, 0, 382, 386, 1, 0,
		0, 0, 383, 385, 5, 68, 0, 0, 384, 383, 1, 0, 0, 0, 385, 388, 1, 0, 0, 0,
		386, 384, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 389, 1, 0, 0, 0, 388,
		386, 1, 0, 0, 0, 389, 390, 5, 2, 0, 0, 390, 391, 5, 63, 0, 0, 391, 31,
		1, 0, 0, 0, 392, 403, 3, 34, 17, 0, 393, 397, 5, 3, 0, 0, 394, 396, 5,
		68, 0, 0, 395, 394, 1, 0, 0, 0, 396, 399, 1, 0, 0, 0, 397, 395, 1, 0, 0,
		0, 397, 398, 1, 0, 0, 0, 398, 400, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 400,
		402, 3, 34, 17, 0, 401, 393, 1, 0, 0, 0, 402, 405, 1, 0, 0, 0, 403, 401,
		1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 33, 1, 0, 0, 0, 405, 403, 1, 0,
		0, 0, 406, 407, 5, 67, 0, 0, 407, 35, 1, 0, 0, 0, 408, 418, 3, 38, 19,
		0, 409, 418, 3, 40, 20, 0, 410, 418, 3, 42, 21, 0, 411, 418, 3, 44, 22,
		0, 412, 418, 3, 46, 23, 0, 413, 418, 3, 48, 24, 0, 414, 418, 3, 50, 25,
		0, 415, 418, 3, 52, 26, 0, 416, 418, 3, 54, 27, 0, 417, 408, 1, 0, 0, 0,
		417, 409, 1, 0, 0, 0, 417, 410, 1, 0, 0, 0, 417, 411, 1, 0, 0, 0, 417,
		412, 1, 0, 0, 0, 417, 413, 1, 0, 0, 0, 417, 414, 1, 0, 0, 0, 417, 415,
		1, 0, 0, 0, 417, 416, 1, 0, 0, 0, 418, 37, 1, 0, 0, 0, 419, 420, 5, 28,
		0, 0, 420, 421, 3, 62, 31, 0, 421, 422, 5, 64, 0, 0, 422, 423, 3, 56, 28,
		0, 423, 424, 5, 63, 0, 0, 424, 39, 1, 0, 0, 0, 425, 426, 5, 29, 0, 0, 426,
		427, 3, 62, 31, 0, 427, 428, 5, 64, 0, 0, 428, 429, 3, 58, 29, 0, 429,
		430, 5, 63, 0, 0, 430, 41, 1, 0, 0, 0, 431, 432, 5, 30, 0, 0, 432, 433,
		3, 62, 31, 0, 433, 434, 5, 64, 0, 0, 434, 435, 3, 56, 28, 0, 435, 436,
		5, 63, 0, 0, 436, 43, 1, 0, 0, 0, 437, 438, 5, 31, 0, 0, 438, 439, 3, 62,
		31, 0, 439, 440, 5, 64, 0, 0, 440, 441, 3, 58, 29, 0, 441, 442, 5, 63,
		0, 0, 442, 45, 1, 0, 0, 0, 443, 444, 5, 32, 0, 0, 444, 445, 3, 62, 31,
		0, 445, 446, 5, 64, 0, 0, 446, 447, 3, 60, 30, 0, 447, 448, 5, 63, 0, 0,
		448, 47, 1, 0, 0, 0, 449, 450, 5, 33, 0, 0, 450, 451, 3, 62, 31, 0, 451,
		452, 5, 64, 0, 0, 452, 453, 5, 67, 0, 0, 453, 454, 5, 63, 0, 0, 454, 49,
		1, 0, 0, 0, 455, 456, 5, 34, 0, 0, 456, 457, 3, 62, 31, 0, 457, 458, 5,
		64, 0, 0, 458, 459, 5, 67, 0, 0, 459, 460, 5, 63, 0, 0, 460, 51, 1, 0,
		0, 0, 461, 462, 5, 35, 0, 0, 462, 463, 3, 62, 31, 0, 463, 464, 5, 64, 0,
		0, 464, 465, 5, 67, 0, 0, 465, 466, 5, 63, 0, 0, 466, 53, 1, 0, 0, 0, 467,
		468, 5, 36, 0, 0, 468, 469, 3, 62, 31, 0, 469, 470, 5, 64, 0, 0, 470, 471,
		5, 67, 0, 0, 471, 472, 5, 63, 0, 0, 472, 55, 1, 0, 0, 0, 473, 474, 5, 57,
		0, 0, 474, 479, 3, 56, 28, 0, 475, 476, 5, 58, 0, 0, 476, 479, 3, 56, 28,
		0, 477, 479, 5, 66, 0, 0, 478, 473, 1, 0, 0, 0, 478, 475, 1, 0, 0, 0, 478,
		477, 1, 0, 0, 0, 479, 57, 1, 0, 0, 0, 480, 481, 5, 57, 0, 0, 481, 484,
		3, 58, 29, 0, 482, 484, 5, 66, 0, 0, 483, 480, 1, 0, 0, 0, 483, 482, 1,
		0, 0, 0, 484, 59, 1, 0, 0, 0, 485, 486, 5, 57, 0, 0, 486, 495, 3, 60, 30,
		0, 487, 488, 5, 58, 0, 0, 488, 495, 3, 60, 30, 0, 489, 492, 5, 66, 0, 0,
		490, 491, 5, 7, 0, 0, 491, 493, 5, 66, 0, 0, 492, 490, 1, 0, 0, 0, 492,
		493, 1, 0, 0, 0, 493, 495, 1, 0, 0, 0, 494, 485, 1, 0, 0, 0, 494, 487,
		1, 0, 0, 0, 494, 489, 1, 0, 0, 0, 495, 61, 1, 0, 0, 0, 496, 497, 5, 65,
		0, 0, 497, 498, 5, 8, 0, 0, 498, 504, 5, 65, 0, 0, 499, 500, 5, 65, 0,
		0, 500, 501, 5, 8, 0, 0, 501, 504, 5, 67, 0, 0, 502, 504, 5, 65, 0, 0,
		503, 496, 1, 0, 0, 0, 503, 499, 1, 0, 0, 0, 503, 502, 1, 0, 0, 0, 504,
		63, 1, 0, 0, 0, 505, 508, 3, 66, 33, 0, 506, 508, 3, 68, 34, 0, 507, 505,
		1, 0, 0, 0, 507, 506, 1, 0, 0, 0, 508, 65, 1, 0, 0, 0, 509, 510, 5, 37,
		0, 0, 510, 511, 3, 62, 31, 0, 511, 512, 5, 64, 0, 0, 512, 513, 3, 70, 35,
		0, 513, 514, 5, 63, 0, 0, 514, 67, 1, 0, 0, 0, 515, 516, 5, 38, 0, 0, 516,
		517, 3, 62, 31, 0, 517, 518, 5, 64, 0, 0, 518, 519, 5, 67, 0, 0, 519, 520,
		5, 63, 0, 0, 520, 69, 1, 0, 0, 0, 521, 525, 3, 98, 49, 0, 522, 525, 5,
		39, 0, 0, 523, 525, 5, 67, 0, 0, 524, 521, 1, 0, 0, 0, 524, 522, 1, 0,
		0, 0, 524, 523, 1, 0, 0, 0, 525, 71, 1, 0, 0, 0, 526, 527, 5, 40, 0, 0,
		527, 528, 3, 62, 31, 0, 528, 532, 5, 1, 0, 0, 529, 531, 5, 68, 0, 0, 530,
		529, 1, 0, 0, 0, 531, 534, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 532, 533,
		1, 0, 0, 0, 533, 535, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535, 539, 3, 74,
		37, 0, 536, 538, 5, 68, 0, 0, 537, 536, 1, 0, 0, 0, 538, 541, 1, 0, 0,
		0, 539, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 542, 1, 0, 0, 0, 541,
		539, 1, 0, 0, 0, 542, 543, 5, 43, 0, 0, 543, 544, 5, 64, 0, 0, 544, 545,
		3, 76, 38, 0, 545, 549, 5, 3, 0, 0, 546, 548, 5, 68, 0, 0, 547, 546, 1,
		0, 0, 0, 548, 551, 1, 0, 0, 0, 549, 547, 1, 0, 0, 0, 549, 550, 1, 0, 0,
		0, 550, 552, 1, 0, 0, 0, 551, 549, 1, 0, 0, 0, 552, 553, 5, 44, 0, 0, 553,
		554, 5, 64, 0, 0, 554, 558, 5, 4, 0, 0, 555, 557, 5, 68, 0, 0, 556, 555,
		1, 0, 0, 0, 557, 560, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 558, 559, 1, 0,
		0, 0, 559, 561, 1, 0, 0, 0, 560, 558, 1, 0, 0, 0, 561, 565, 3, 80, 40,
		0, 562, 564, 5, 68, 0, 0, 563, 562, 1, 0, 0, 0, 564, 567, 1, 0, 0, 0, 565,
		563, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 568, 1, 0, 0, 0, 567, 565,
		1, 0, 0, 0, 568, 570, 5, 5, 0, 0, 569, 571, 5, 3, 0, 0, 570, 569, 1, 0,
		0, 0, 570, 571, 1, 0, 0, 0, 571, 575, 1, 0, 0, 0, 572, 574, 5, 68, 0, 0,
		573, 572, 1, 0, 0, 0, 574, 577, 1, 0, 0, 0, 575, 573, 1, 0, 0, 0, 575,
		576, 1, 0, 0, 0, 576, 578, 1, 0, 0, 0, 577, 575, 1, 0, 0, 0, 578, 579,
		5, 2, 0, 0, 579, 580, 5, 63, 0, 0, 580, 73, 1, 0, 0, 0, 581, 582, 5, 41,
		0, 0, 582, 583, 5, 64, 0, 0, 583, 584, 3, 62, 31, 0, 584, 585, 5, 3, 0,
		0, 585, 591, 1, 0, 0, 0, 586, 587, 5, 42, 0, 0, 587, 588, 5, 64, 0, 0,
		588, 589, 5, 67, 0, 0, 589, 591, 5, 3, 0, 0, 590, 581, 1, 0, 0, 0, 590,
		586, 1, 0, 0, 0, 591, 75, 1, 0, 0, 0, 592, 594, 5, 4, 0, 0, 593, 595, 3,
		78, 39, 0, 594, 593, 1, 0, 0, 0, 594, 595, 1, 0, 0, 0, 595, 596, 1, 0,
		0, 0, 596, 597, 5, 5, 0, 0, 597, 77, 1, 0, 0, 0, 598, 603, 5, 67, 0, 0,
		599, 600, 5, 3, 0, 0, 600, 602, 5, 67, 0, 0, 601, 599, 1, 0, 0, 0, 602,
		605, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 79, 1,
		0, 0, 0, 605, 603, 1, 0, 0, 0, 606, 617, 3, 82, 41, 0, 607, 611, 5, 3,
		0, 0, 608, 610, 5, 68, 0, 0, 609, 608, 1, 0, 0, 0, 610, 613, 1, 0, 0, 0,
		611, 609, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 614, 1, 0, 0, 0, 613,
		611, 1, 0, 0, 0, 614, 616, 3, 82, 41, 0, 615, 607, 1, 0, 0, 0, 616, 619,
		1, 0, 0, 0, 617, 615, 1, 0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 81, 1, 0,
		0, 0, 619, 617, 1, 0, 0, 0, 620, 621, 5, 67, 0, 0, 621, 623, 5, 6, 0, 0,
		622, 624, 5, 18, 0, 0, 623, 622, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624,
		625, 1, 0, 0, 0, 625, 626, 3, 22, 11, 0, 626, 83, 1, 0, 0, 0, 627, 628,
		5, 4, 0, 0, 628, 632, 5, 65, 0, 0, 629, 631, 3, 86, 43, 0, 630, 629, 1,
		0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 632, 633, 1, 0, 0,
		0, 633, 635, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635, 636, 5, 5, 0, 0, 636,
		640, 5, 8, 0, 0, 637, 639, 5, 68, 0, 0, 638, 637, 1, 0, 0, 0, 639, 642,
		1, 0, 0, 0, 640, 638, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 650, 1, 0,
		0, 0, 642, 640, 1, 0, 0, 0, 643, 647, 3, 90, 45, 0, 644, 646, 5, 68, 0,
		0, 645, 644, 1, 0, 0, 0, 646, 649, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 647,
		648, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 650, 643,
		1, 0, 0, 0, 651, 652, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 652, 653, 1, 0,
		0, 0, 653, 654, 1, 0, 0, 0, 654, 658, 5, 9, 0, 0, 655, 657, 5, 68, 0, 0,
		656, 655, 1, 0, 0, 0, 657, 660, 1, 0, 0, 0, 658, 656, 1, 0, 0, 0, 658,
		659, 1, 0, 0, 0, 659, 668, 1, 0, 0, 0, 660, 658, 1, 0, 0, 0, 661, 665,
		3, 92, 46, 0, 662, 664, 5, 68, 0, 0, 663, 662, 1, 0, 0, 0, 664, 667, 1,
		0, 0, 0, 665, 663, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666, 669, 1, 0, 0,
		0, 667, 665, 1, 0, 0, 0, 668, 661, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670,
		668, 1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673,
		5, 63, 0, 0, 673, 85, 1, 0, 0, 0, 674, 675, 5, 3, 0, 0, 675, 676, 5, 65,
		0, 0, 676, 677, 5, 64, 0, 0, 677, 678, 3, 88, 44, 0, 678, 87, 1, 0, 0,
		0, 679, 684, 5, 67, 0, 0, 680, 684, 5, 45, 0, 0, 681, 684, 5, 46, 0, 0,
		682, 684, 3, 56, 28, 0, 683, 679, 1, 0, 0, 0, 683, 680, 1, 0, 0, 0, 683,
		681, 1, 0, 0, 0, 683, 682, 1, 0, 0, 0, 684, 89, 1, 0, 0, 0, 685, 687, 5,
		48, 0, 0, 686, 685, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 688, 1, 0, 0,
		0, 688, 689, 5, 10, 0, 0, 689, 690, 3, 94, 47, 0, 690, 691, 3, 94, 47,
		0, 691, 692, 3, 96, 48, 0, 692, 694, 5, 11, 0, 0, 693, 695, 5, 7, 0, 0,
		694, 693, 1, 0, 0, 0, 694, 695, 1, 0, 0, 0, 695, 702, 1, 0, 0, 0, 696,
		697, 5, 4, 0, 0, 697, 698, 3, 100, 50, 0, 698, 700, 5, 5, 0, 0, 699, 701,
		5, 7, 0, 0, 700, 699, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 703, 1, 0,
		0, 0, 702, 696, 1, 0, 0, 0, 702, 703, 1, 0, 0, 0, 703, 91, 1, 0, 0, 0,
		704, 705, 5, 10, 0, 0, 705, 706, 3, 94, 47, 0, 706, 707, 3, 94, 47, 0,
		707, 708, 3, 100, 50, 0, 708, 710, 5, 11, 0, 0, 709, 711, 5, 7, 0, 0, 710,
		709, 1, 0, 0, 0, 710, 711, 1, 0, 0, 0, 711, 93, 1, 0, 0, 0, 712, 713, 5,
		12, 0, 0, 713, 716, 5, 65, 0, 0, 714, 716, 3, 62, 31, 0, 715, 712, 1, 0,
		0, 0, 715, 714, 1, 0, 0, 0, 716, 95, 1, 0, 0, 0, 717, 763, 3, 94, 47, 0,
		718, 719, 5, 28, 0, 0, 719, 720, 5, 10, 0, 0, 720, 721, 3, 56, 28, 0, 721,
		722, 5, 11, 0, 0, 722, 763, 1, 0, 0, 0, 723, 724, 5, 29, 0, 0, 724, 725,
		5, 10, 0, 0, 725, 726, 3, 58, 29, 0, 726, 727, 5, 11, 0, 0, 727, 763, 1,
		0, 0, 0, 728, 729, 5, 30, 0, 0, 729, 730, 5, 10, 0, 0, 730, 731, 3, 56,
		28, 0, 731, 732, 5, 11, 0, 0, 732, 763, 1, 0, 0, 0, 733, 734, 5, 31, 0,
		0, 734, 735, 5, 10, 0, 0, 735, 736, 3, 58, 29, 0, 736, 737, 5, 11, 0, 0,
		737, 763, 1, 0, 0, 0, 738, 739, 5, 32, 0, 0, 739, 740, 5, 10, 0, 0, 740,
		741, 3, 60, 30, 0, 741, 742, 5, 11, 0, 0, 742, 763, 1, 0, 0, 0, 743, 744,
		5, 33, 0, 0, 744, 745, 5, 10, 0, 0, 745, 746, 5, 67, 0, 0, 746, 763, 5,
		11, 0, 0, 747, 748, 5, 34, 0, 0, 748, 749, 5, 10, 0, 0, 749, 750, 5, 67,
		0, 0, 750, 763, 5, 11, 0, 0, 751, 752, 5, 35, 0, 0, 752, 753, 5, 10, 0,
		0, 753, 754, 5, 67, 0, 0, 754, 763, 5, 11, 0, 0, 755, 756, 5, 36, 0, 0,
		756, 757, 5, 10, 0, 0, 757, 758, 5, 67, 0, 0, 758, 763, 5, 11, 0, 0, 759,
		763, 5, 67, 0, 0, 760, 763, 3, 98, 49, 0, 761, 763, 3, 60, 30, 0, 762,
		717, 1, 0, 0, 0, 762, 718, 1, 0, 0, 0, 762, 723, 1, 0, 0, 0, 762, 728,
		1, 0, 0, 0, 762, 733, 1, 0, 0, 0, 762, 738, 1, 0, 0, 0, 762, 743, 1, 0,
		0, 0, 762, 747, 1, 0, 0, 0, 762, 751, 1, 0, 0, 0, 762, 755, 1, 0, 0, 0,
		762, 759, 1, 0, 0, 0, 762, 760, 1, 0, 0, 0, 762, 761, 1, 0, 0, 0, 763,
		97, 1, 0, 0, 0, 764, 765, 7, 3, 0, 0, 765, 99, 1, 0, 0, 0, 766, 767, 6,
		50, -1, 0, 767, 768, 5, 10, 0, 0, 768, 769, 3, 100, 50, 0, 769, 770, 3,
		102, 51, 0, 770, 771, 3, 100, 50, 0, 771, 772, 5, 11, 0, 0, 772, 792, 1,
		0, 0, 0, 773, 774, 3, 104, 52, 0, 774, 775, 5, 10, 0, 0, 775, 776, 3, 100,
		50, 0, 776, 777, 5, 11, 0, 0, 777, 792, 1, 0, 0, 0, 778, 779, 5, 10, 0,
		0, 779, 780, 3, 104, 52, 0, 780, 781, 3, 100, 50, 0, 781, 782, 5, 11, 0,
		0, 782, 792, 1, 0, 0, 0, 783, 784, 5, 10, 0, 0, 784, 785, 3, 100, 50, 0,
		785, 786, 5, 11, 0, 0, 786, 792, 1, 0, 0, 0, 787, 788, 3, 104, 52, 0, 788,
		789, 3, 100, 50, 2, 789, 792, 1, 0, 0, 0, 790, 792, 3, 96, 48, 0, 791,
		766, 1, 0, 0, 0, 791, 773, 1, 0, 0, 0, 791, 778, 1, 0, 0, 0, 791, 783,
		1, 0, 0, 0, 791, 787, 1, 0, 0, 0, 791, 790, 1, 0, 0, 0, 792, 799, 1, 0,
		0, 0, 793, 794, 10, 7, 0, 0, 794, 795, 3, 102, 51, 0, 795, 796, 3, 100,
		50, 8, 796, 798, 1, 0, 0, 0, 797, 793, 1, 0, 0, 0, 798, 801, 1, 0, 0, 0,
		799, 797, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 101, 1, 0, 0, 0, 801,
		799, 1, 0, 0, 0, 802, 803, 7, 4, 0, 0, 803, 103, 1, 0, 0, 0, 804, 805,
		7, 5, 0, 0, 805, 105, 1, 0, 0, 0, 806, 807, 5, 27, 0, 0, 807, 808, 5, 10,
		0, 0, 808, 809, 3, 94, 47, 0, 809, 810, 5, 3, 0, 0, 810, 811, 3, 94, 47,
		0, 811, 812, 5, 3, 0, 0, 812, 813, 3, 96, 48, 0, 813, 814, 5, 11, 0, 0,
		814, 815, 5, 63, 0, 0, 815, 107, 1, 0, 0, 0, 74, 111, 126, 139, 146, 159,
		165, 180, 188, 194, 200, 205, 213, 221, 227, 233, 245, 253, 259, 265, 276,
		284, 290, 296, 307, 315, 321, 327, 333, 340, 360, 369, 376, 381, 386, 397,
		403, 417, 478, 483, 492, 494, 503, 507, 524, 532, 539, 549, 558, 565, 570,
		575, 590, 594, 603, 611, 617, 623, 632, 640, 647, 652, 658, 665, 670, 683,
		686, 694, 700, 702, 710, 715, 762, 791, 799,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// JetRuleParserInit initializes any static state used to implement JetRuleParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewJetRuleParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func JetRuleParserInit() {
	staticData := &JetRuleParserStaticData
	staticData.once.Do(jetruleParserInit)
}

// NewJetRuleParser produces a new parser instance for the optional input antlr.TokenStream.
func NewJetRuleParser(input antlr.TokenStream) *JetRuleParser {
	JetRuleParserInit()
	this := new(JetRuleParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &JetRuleParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "JetRule.g4"

	return this
}

// JetRuleParser tokens.
const (
	JetRuleParserEOF                  = antlr.TokenEOF
	JetRuleParserT__0                 = 1
	JetRuleParserT__1                 = 2
	JetRuleParserT__2                 = 3
	JetRuleParserT__3                 = 4
	JetRuleParserT__4                 = 5
	JetRuleParserT__5                 = 6
	JetRuleParserT__6                 = 7
	JetRuleParserT__7                 = 8
	JetRuleParserT__8                 = 9
	JetRuleParserT__9                 = 10
	JetRuleParserT__10                = 11
	JetRuleParserT__11                = 12
	JetRuleParserJetCompilerDirective = 13
	JetRuleParserCLASS                = 14
	JetRuleParserBaseClasses          = 15
	JetRuleParserAsTable              = 16
	JetRuleParserDataProperties       = 17
	JetRuleParserARRAY                = 18
	JetRuleParserGroupingProperties   = 19
	JetRuleParserMAIN                 = 20
	JetRuleParserJETSCONFIG           = 21
	JetRuleParserMaxLooping           = 22
	JetRuleParserMaxRuleExec          = 23
	JetRuleParserInputType            = 24
	JetRuleParserRULESEQ              = 25
	JetRuleParserMainRuleSets         = 26
	JetRuleParserTRIPLE               = 27
	JetRuleParserInt32Type            = 28
	JetRuleParserUInt32Type           = 29
	JetRuleParserInt64Type            = 30
	JetRuleParserUInt64Type           = 31
	JetRuleParserDoubleType           = 32
	JetRuleParserStringType           = 33
	JetRuleParserDateType             = 34
	JetRuleParserDatetimeType         = 35
	JetRuleParserBoolType             = 36
	JetRuleParserResourceType         = 37
	JetRuleParserVolatileResourceType = 38
	JetRuleParserCreateUUIDResource   = 39
	JetRuleParserLookupTable          = 40
	JetRuleParserTableName            = 41
	JetRuleParserCSVFileName          = 42
	JetRuleParserKey                  = 43
	JetRuleParserColumns              = 44
	JetRuleParserTRUE                 = 45
	JetRuleParserFALSE                = 46
	JetRuleParserNULL                 = 47
	JetRuleParserNOT                  = 48
	JetRuleParserTOTEXT               = 49
	JetRuleParserEQ                   = 50
	JetRuleParserLT                   = 51
	JetRuleParserLE                   = 52
	JetRuleParserGT                   = 53
	JetRuleParserGE                   = 54
	JetRuleParserNE                   = 55
	JetRuleParserREGEX2               = 56
	JetRuleParserPLUS                 = 57
	JetRuleParserMINUS                = 58
	JetRuleParserMUL                  = 59
	JetRuleParserDIV                  = 60
	JetRuleParserOR                   = 61
	JetRuleParserAND                  = 62
	JetRuleParserSEMICOLON            = 63
	JetRuleParserASSIGN               = 64
	JetRuleParserIdentifier           = 65
	JetRuleParserDIGITS               = 66
	JetRuleParserSTRING               = 67
	JetRuleParserCOMMENT              = 68
	JetRuleParserWS                   = 69
)

// JetRuleParser rules.
const (
	JetRuleParserRULE_jetrule                  = 0
	JetRuleParserRULE_statement                = 1
	JetRuleParserRULE_jetCompilerDirectiveStmt = 2
	JetRuleParserRULE_defineJetStoreConfigStmt = 3
	JetRuleParserRULE_jetstoreConfig           = 4
	JetRuleParserRULE_jetstoreConfigSeq        = 5
	JetRuleParserRULE_jetstoreConfigItem       = 6
	JetRuleParserRULE_defineClassStmt          = 7
	JetRuleParserRULE_classStmt                = 8
	JetRuleParserRULE_subClassOfStmt           = 9
	JetRuleParserRULE_dataPropertyDefinitions  = 10
	JetRuleParserRULE_dataPropertyType         = 11
	JetRuleParserRULE_groupingPropertyStmt     = 12
	JetRuleParserRULE_asTableStmt              = 13
	JetRuleParserRULE_asTableFlag              = 14
	JetRuleParserRULE_defineRuleSeqStmt        = 15
	JetRuleParserRULE_ruleSetSeq               = 16
	JetRuleParserRULE_ruleSetDefinitions       = 17
	JetRuleParserRULE_defineLiteralStmt        = 18
	JetRuleParserRULE_int32LiteralStmt         = 19
	JetRuleParserRULE_uInt32LiteralStmt        = 20
	JetRuleParserRULE_int64LiteralStmt         = 21
	JetRuleParserRULE_uInt64LiteralStmt        = 22
	JetRuleParserRULE_doubleLiteralStmt        = 23
	JetRuleParserRULE_stringLiteralStmt        = 24
	JetRuleParserRULE_dateLiteralStmt          = 25
	JetRuleParserRULE_datetimeLiteralStmt      = 26
	JetRuleParserRULE_booleanLiteralStmt       = 27
	JetRuleParserRULE_intExpr                  = 28
	JetRuleParserRULE_uintExpr                 = 29
	JetRuleParserRULE_doubleExpr               = 30
	JetRuleParserRULE_declIdentifier           = 31
	JetRuleParserRULE_defineResourceStmt       = 32
	JetRuleParserRULE_namedResourceStmt        = 33
	JetRuleParserRULE_volatileResourceStmt     = 34
	JetRuleParserRULE_resourceValue            = 35
	JetRuleParserRULE_lookupTableStmt          = 36
	JetRuleParserRULE_csvLocation              = 37
	JetRuleParserRULE_stringList               = 38
	JetRuleParserRULE_stringSeq                = 39
	JetRuleParserRULE_columnDefSeq             = 40
	JetRuleParserRULE_columnDefinitions        = 41
	JetRuleParserRULE_jetRuleStmt              = 42
	JetRuleParserRULE_ruleProperties           = 43
	JetRuleParserRULE_propertyValue            = 44
	JetRuleParserRULE_antecedent               = 45
	JetRuleParserRULE_consequent               = 46
	JetRuleParserRULE_atom                     = 47
	JetRuleParserRULE_objectAtom               = 48
	JetRuleParserRULE_keywords                 = 49
	JetRuleParserRULE_exprTerm                 = 50
	JetRuleParserRULE_binaryOp                 = 51
	JetRuleParserRULE_unaryOp                  = 52
	JetRuleParserRULE_tripleStmt               = 53
)

// IJetruleContext is an interface to support dynamic dispatch.
type IJetruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsJetruleContext differentiates from other interfaces.
	IsJetruleContext()
}

type JetruleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJetruleContext() *JetruleContext {
	var p = new(JetruleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetrule
	return p
}

func InitEmptyJetruleContext(p *JetruleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetrule
}

func (*JetruleContext) IsJetruleContext() {}

func NewJetruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JetruleContext {
	var p = new(JetruleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_jetrule

	return p
}

func (s *JetruleContext) GetParser() antlr.Parser { return s.parser }

func (s *JetruleContext) EOF() antlr.TerminalNode {
	return s.GetToken(JetRuleParserEOF, 0)
}

func (s *JetruleContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *JetruleContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *JetruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JetruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JetruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterJetrule(s)
	}
}

func (s *JetruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitJetrule(s)
	}
}

func (p *JetRuleParser) Jetrule() (localctx IJetruleContext) {
	localctx = NewJetruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, JetRuleParserRULE_jetrule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1649169948688) != 0) || _la == JetRuleParserCOMMENT {
		{
			p.SetState(108)
			p.Statement()
		}

		p.SetState(113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(114)
		p.Match(JetRuleParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JetCompilerDirectiveStmt() IJetCompilerDirectiveStmtContext
	DefineJetStoreConfigStmt() IDefineJetStoreConfigStmtContext
	DefineLiteralStmt() IDefineLiteralStmtContext
	DefineClassStmt() IDefineClassStmtContext
	DefineRuleSeqStmt() IDefineRuleSeqStmtContext
	DefineResourceStmt() IDefineResourceStmtContext
	LookupTableStmt() ILookupTableStmtContext
	JetRuleStmt() IJetRuleStmtContext
	TripleStmt() ITripleStmtContext
	COMMENT() antlr.TerminalNode

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) JetCompilerDirectiveStmt() IJetCompilerDirectiveStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJetCompilerDirectiveStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJetCompilerDirectiveStmtContext)
}

func (s *StatementContext) DefineJetStoreConfigStmt() IDefineJetStoreConfigStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineJetStoreConfigStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineJetStoreConfigStmtContext)
}

func (s *StatementContext) DefineLiteralStmt() IDefineLiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineLiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineLiteralStmtContext)
}

func (s *StatementContext) DefineClassStmt() IDefineClassStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineClassStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineClassStmtContext)
}

func (s *StatementContext) DefineRuleSeqStmt() IDefineRuleSeqStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineRuleSeqStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineRuleSeqStmtContext)
}

func (s *StatementContext) DefineResourceStmt() IDefineResourceStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefineResourceStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefineResourceStmtContext)
}

func (s *StatementContext) LookupTableStmt() ILookupTableStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupTableStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupTableStmtContext)
}

func (s *StatementContext) JetRuleStmt() IJetRuleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJetRuleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJetRuleStmtContext)
}

func (s *StatementContext) TripleStmt() ITripleStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITripleStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITripleStmtContext)
}

func (s *StatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *JetRuleParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, JetRuleParserRULE_statement)
	p.SetState(126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserJetCompilerDirective:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(116)
			p.JetCompilerDirectiveStmt()
		}

	case JetRuleParserMAIN, JetRuleParserJETSCONFIG:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(117)
			p.DefineJetStoreConfigStmt()
		}

	case JetRuleParserInt32Type, JetRuleParserUInt32Type, JetRuleParserInt64Type, JetRuleParserUInt64Type, JetRuleParserDoubleType, JetRuleParserStringType, JetRuleParserDateType, JetRuleParserDatetimeType, JetRuleParserBoolType:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(118)
			p.DefineLiteralStmt()
		}

	case JetRuleParserCLASS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(119)
			p.DefineClassStmt()
		}

	case JetRuleParserRULESEQ:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(120)
			p.DefineRuleSeqStmt()
		}

	case JetRuleParserResourceType, JetRuleParserVolatileResourceType:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(121)
			p.DefineResourceStmt()
		}

	case JetRuleParserLookupTable:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(122)
			p.LookupTableStmt()
		}

	case JetRuleParserT__3:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(123)
			p.JetRuleStmt()
		}

	case JetRuleParserTRIPLE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(124)
			p.TripleStmt()
		}

	case JetRuleParserCOMMENT:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(125)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJetCompilerDirectiveStmtContext is an interface to support dynamic dispatch.
type IJetCompilerDirectiveStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDeclValue returns the declValue token.
	GetDeclValue() antlr.Token

	// SetDeclValue sets the declValue token.
	SetDeclValue(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// Getter signatures
	JetCompilerDirective() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	STRING() antlr.TerminalNode

	// IsJetCompilerDirectiveStmtContext differentiates from other interfaces.
	IsJetCompilerDirectiveStmtContext()
}

type JetCompilerDirectiveStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varName   IDeclIdentifierContext
	declValue antlr.Token
}

func NewEmptyJetCompilerDirectiveStmtContext() *JetCompilerDirectiveStmtContext {
	var p = new(JetCompilerDirectiveStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetCompilerDirectiveStmt
	return p
}

func InitEmptyJetCompilerDirectiveStmtContext(p *JetCompilerDirectiveStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetCompilerDirectiveStmt
}

func (*JetCompilerDirectiveStmtContext) IsJetCompilerDirectiveStmtContext() {}

func NewJetCompilerDirectiveStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JetCompilerDirectiveStmtContext {
	var p = new(JetCompilerDirectiveStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_jetCompilerDirectiveStmt

	return p
}

func (s *JetCompilerDirectiveStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *JetCompilerDirectiveStmtContext) GetDeclValue() antlr.Token { return s.declValue }

func (s *JetCompilerDirectiveStmtContext) SetDeclValue(v antlr.Token) { s.declValue = v }

func (s *JetCompilerDirectiveStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *JetCompilerDirectiveStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *JetCompilerDirectiveStmtContext) JetCompilerDirective() antlr.TerminalNode {
	return s.GetToken(JetRuleParserJetCompilerDirective, 0)
}

func (s *JetCompilerDirectiveStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *JetCompilerDirectiveStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *JetCompilerDirectiveStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *JetCompilerDirectiveStmtContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *JetCompilerDirectiveStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JetCompilerDirectiveStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JetCompilerDirectiveStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterJetCompilerDirectiveStmt(s)
	}
}

func (s *JetCompilerDirectiveStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitJetCompilerDirectiveStmt(s)
	}
}

func (p *JetRuleParser) JetCompilerDirectiveStmt() (localctx IJetCompilerDirectiveStmtContext) {
	localctx = NewJetCompilerDirectiveStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, JetRuleParserRULE_jetCompilerDirectiveStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(128)
		p.Match(JetRuleParserJetCompilerDirective)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(129)

		var _x = p.DeclIdentifier()

		localctx.(*JetCompilerDirectiveStmtContext).varName = _x
	}
	{
		p.SetState(130)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(131)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*JetCompilerDirectiveStmtContext).declValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(132)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefineJetStoreConfigStmtContext is an interface to support dynamic dispatch.
type IDefineJetStoreConfigStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JetstoreConfig() IJetstoreConfigContext
	JetstoreConfigSeq() IJetstoreConfigSeqContext
	SEMICOLON() antlr.TerminalNode
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsDefineJetStoreConfigStmtContext differentiates from other interfaces.
	IsDefineJetStoreConfigStmtContext()
}

type DefineJetStoreConfigStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefineJetStoreConfigStmtContext() *DefineJetStoreConfigStmtContext {
	var p = new(DefineJetStoreConfigStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineJetStoreConfigStmt
	return p
}

func InitEmptyDefineJetStoreConfigStmtContext(p *DefineJetStoreConfigStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineJetStoreConfigStmt
}

func (*DefineJetStoreConfigStmtContext) IsDefineJetStoreConfigStmtContext() {}

func NewDefineJetStoreConfigStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineJetStoreConfigStmtContext {
	var p = new(DefineJetStoreConfigStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_defineJetStoreConfigStmt

	return p
}

func (s *DefineJetStoreConfigStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineJetStoreConfigStmtContext) JetstoreConfig() IJetstoreConfigContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJetstoreConfigContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJetstoreConfigContext)
}

func (s *DefineJetStoreConfigStmtContext) JetstoreConfigSeq() IJetstoreConfigSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJetstoreConfigSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJetstoreConfigSeqContext)
}

func (s *DefineJetStoreConfigStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *DefineJetStoreConfigStmtContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *DefineJetStoreConfigStmtContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *DefineJetStoreConfigStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineJetStoreConfigStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineJetStoreConfigStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDefineJetStoreConfigStmt(s)
	}
}

func (s *DefineJetStoreConfigStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDefineJetStoreConfigStmt(s)
	}
}

func (p *JetRuleParser) DefineJetStoreConfigStmt() (localctx IDefineJetStoreConfigStmtContext) {
	localctx = NewDefineJetStoreConfigStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, JetRuleParserRULE_defineJetStoreConfigStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(134)
		p.JetstoreConfig()
	}
	{
		p.SetState(135)
		p.Match(JetRuleParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(136)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(142)
		p.JetstoreConfigSeq()
	}
	p.SetState(146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(143)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(149)
		p.Match(JetRuleParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(150)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJetstoreConfigContext is an interface to support dynamic dispatch.
type IJetstoreConfigContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JETSCONFIG() antlr.TerminalNode
	MAIN() antlr.TerminalNode

	// IsJetstoreConfigContext differentiates from other interfaces.
	IsJetstoreConfigContext()
}

type JetstoreConfigContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJetstoreConfigContext() *JetstoreConfigContext {
	var p = new(JetstoreConfigContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetstoreConfig
	return p
}

func InitEmptyJetstoreConfigContext(p *JetstoreConfigContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetstoreConfig
}

func (*JetstoreConfigContext) IsJetstoreConfigContext() {}

func NewJetstoreConfigContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JetstoreConfigContext {
	var p = new(JetstoreConfigContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_jetstoreConfig

	return p
}

func (s *JetstoreConfigContext) GetParser() antlr.Parser { return s.parser }

func (s *JetstoreConfigContext) JETSCONFIG() antlr.TerminalNode {
	return s.GetToken(JetRuleParserJETSCONFIG, 0)
}

func (s *JetstoreConfigContext) MAIN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMAIN, 0)
}

func (s *JetstoreConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JetstoreConfigContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JetstoreConfigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterJetstoreConfig(s)
	}
}

func (s *JetstoreConfigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitJetstoreConfig(s)
	}
}

func (p *JetRuleParser) JetstoreConfig() (localctx IJetstoreConfigContext) {
	localctx = NewJetstoreConfigContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, JetRuleParserRULE_jetstoreConfig)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(152)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JetRuleParserMAIN || _la == JetRuleParserJETSCONFIG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJetstoreConfigSeqContext is an interface to support dynamic dispatch.
type IJetstoreConfigSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJetstoreConfigItem() []IJetstoreConfigItemContext
	JetstoreConfigItem(i int) IJetstoreConfigItemContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsJetstoreConfigSeqContext differentiates from other interfaces.
	IsJetstoreConfigSeqContext()
}

type JetstoreConfigSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJetstoreConfigSeqContext() *JetstoreConfigSeqContext {
	var p = new(JetstoreConfigSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetstoreConfigSeq
	return p
}

func InitEmptyJetstoreConfigSeqContext(p *JetstoreConfigSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetstoreConfigSeq
}

func (*JetstoreConfigSeqContext) IsJetstoreConfigSeqContext() {}

func NewJetstoreConfigSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JetstoreConfigSeqContext {
	var p = new(JetstoreConfigSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_jetstoreConfigSeq

	return p
}

func (s *JetstoreConfigSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *JetstoreConfigSeqContext) AllJetstoreConfigItem() []IJetstoreConfigItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJetstoreConfigItemContext); ok {
			len++
		}
	}

	tst := make([]IJetstoreConfigItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJetstoreConfigItemContext); ok {
			tst[i] = t.(IJetstoreConfigItemContext)
			i++
		}
	}

	return tst
}

func (s *JetstoreConfigSeqContext) JetstoreConfigItem(i int) IJetstoreConfigItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJetstoreConfigItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJetstoreConfigItemContext)
}

func (s *JetstoreConfigSeqContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *JetstoreConfigSeqContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *JetstoreConfigSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JetstoreConfigSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JetstoreConfigSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterJetstoreConfigSeq(s)
	}
}

func (s *JetstoreConfigSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitJetstoreConfigSeq(s)
	}
}

func (p *JetRuleParser) JetstoreConfigSeq() (localctx IJetstoreConfigSeqContext) {
	localctx = NewJetstoreConfigSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, JetRuleParserRULE_jetstoreConfigSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)
		p.JetstoreConfigItem()
	}
	p.SetState(165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserT__2 {
		{
			p.SetState(155)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(156)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(161)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(162)
			p.JetstoreConfigItem()
		}

		p.SetState(167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJetstoreConfigItemContext is an interface to support dynamic dispatch.
type IJetstoreConfigItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConfigKey returns the configKey token.
	GetConfigKey() antlr.Token

	// SetConfigKey sets the configKey token.
	SetConfigKey(antlr.Token)

	// GetConfigValue returns the configValue rule contexts.
	GetConfigValue() IUintExprContext

	// Get_declIdentifier returns the _declIdentifier rule contexts.
	Get_declIdentifier() IDeclIdentifierContext

	// SetConfigValue sets the configValue rule contexts.
	SetConfigValue(IUintExprContext)

	// Set_declIdentifier sets the _declIdentifier rule contexts.
	Set_declIdentifier(IDeclIdentifierContext)

	// GetRdfTypeList returns the rdfTypeList rule context list.
	GetRdfTypeList() []IDeclIdentifierContext

	// SetRdfTypeList sets the rdfTypeList rule context list.
	SetRdfTypeList([]IDeclIdentifierContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	MaxLooping() antlr.TerminalNode
	UintExpr() IUintExprContext
	MaxRuleExec() antlr.TerminalNode
	InputType() antlr.TerminalNode
	AllDeclIdentifier() []IDeclIdentifierContext
	DeclIdentifier(i int) IDeclIdentifierContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsJetstoreConfigItemContext differentiates from other interfaces.
	IsJetstoreConfigItemContext()
}

type JetstoreConfigItemContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	configKey       antlr.Token
	configValue     IUintExprContext
	_declIdentifier IDeclIdentifierContext
	rdfTypeList     []IDeclIdentifierContext
}

func NewEmptyJetstoreConfigItemContext() *JetstoreConfigItemContext {
	var p = new(JetstoreConfigItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetstoreConfigItem
	return p
}

func InitEmptyJetstoreConfigItemContext(p *JetstoreConfigItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetstoreConfigItem
}

func (*JetstoreConfigItemContext) IsJetstoreConfigItemContext() {}

func NewJetstoreConfigItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JetstoreConfigItemContext {
	var p = new(JetstoreConfigItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_jetstoreConfigItem

	return p
}

func (s *JetstoreConfigItemContext) GetParser() antlr.Parser { return s.parser }

func (s *JetstoreConfigItemContext) GetConfigKey() antlr.Token { return s.configKey }

func (s *JetstoreConfigItemContext) SetConfigKey(v antlr.Token) { s.configKey = v }

func (s *JetstoreConfigItemContext) GetConfigValue() IUintExprContext { return s.configValue }

func (s *JetstoreConfigItemContext) Get_declIdentifier() IDeclIdentifierContext {
	return s._declIdentifier
}

func (s *JetstoreConfigItemContext) SetConfigValue(v IUintExprContext) { s.configValue = v }

func (s *JetstoreConfigItemContext) Set_declIdentifier(v IDeclIdentifierContext) {
	s._declIdentifier = v
}

func (s *JetstoreConfigItemContext) GetRdfTypeList() []IDeclIdentifierContext { return s.rdfTypeList }

func (s *JetstoreConfigItemContext) SetRdfTypeList(v []IDeclIdentifierContext) { s.rdfTypeList = v }

func (s *JetstoreConfigItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *JetstoreConfigItemContext) MaxLooping() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMaxLooping, 0)
}

func (s *JetstoreConfigItemContext) UintExpr() IUintExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUintExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUintExprContext)
}

func (s *JetstoreConfigItemContext) MaxRuleExec() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMaxRuleExec, 0)
}

func (s *JetstoreConfigItemContext) InputType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInputType, 0)
}

func (s *JetstoreConfigItemContext) AllDeclIdentifier() []IDeclIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclIdentifierContext); ok {
			tst[i] = t.(IDeclIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JetstoreConfigItemContext) DeclIdentifier(i int) IDeclIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *JetstoreConfigItemContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *JetstoreConfigItemContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *JetstoreConfigItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JetstoreConfigItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JetstoreConfigItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterJetstoreConfigItem(s)
	}
}

func (s *JetstoreConfigItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitJetstoreConfigItem(s)
	}
}

func (p *JetRuleParser) JetstoreConfigItem() (localctx IJetstoreConfigItemContext) {
	localctx = NewJetstoreConfigItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, JetRuleParserRULE_jetstoreConfigItem)
	var _la int

	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserMaxLooping:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(168)

			var _m = p.Match(JetRuleParserMaxLooping)

			localctx.(*JetstoreConfigItemContext).configKey = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(169)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(170)

			var _x = p.UintExpr()

			localctx.(*JetstoreConfigItemContext).configValue = _x
		}

	case JetRuleParserMaxRuleExec:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(171)

			var _m = p.Match(JetRuleParserMaxRuleExec)

			localctx.(*JetstoreConfigItemContext).configKey = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(172)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(173)

			var _x = p.UintExpr()

			localctx.(*JetstoreConfigItemContext).configValue = _x
		}

	case JetRuleParserInputType:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(174)

			var _m = p.Match(JetRuleParserInputType)

			localctx.(*JetstoreConfigItemContext).configKey = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(175)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(176)
			p.Match(JetRuleParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(177)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(182)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(183)

			var _x = p.DeclIdentifier()

			localctx.(*JetstoreConfigItemContext)._declIdentifier = _x
		}
		localctx.(*JetstoreConfigItemContext).rdfTypeList = append(localctx.(*JetstoreConfigItemContext).rdfTypeList, localctx.(*JetstoreConfigItemContext)._declIdentifier)
		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserT__2 {
			{
				p.SetState(184)
				p.Match(JetRuleParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(188)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == JetRuleParserCOMMENT {
				{
					p.SetState(185)
					p.Match(JetRuleParserCOMMENT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(190)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(191)

				var _x = p.DeclIdentifier()

				localctx.(*JetstoreConfigItemContext)._declIdentifier = _x
			}
			localctx.(*JetstoreConfigItemContext).rdfTypeList = append(localctx.(*JetstoreConfigItemContext).rdfTypeList, localctx.(*JetstoreConfigItemContext)._declIdentifier)

			p.SetState(196)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(197)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(202)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(203)
			p.Match(JetRuleParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefineClassStmtContext is an interface to support dynamic dispatch.
type IDefineClassStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClassName returns the className rule contexts.
	GetClassName() IDeclIdentifierContext

	// SetClassName sets the className rule contexts.
	SetClassName(IDeclIdentifierContext)

	// Getter signatures
	CLASS() antlr.TerminalNode
	AllClassStmt() []IClassStmtContext
	ClassStmt(i int) IClassStmtContext
	SEMICOLON() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsDefineClassStmtContext differentiates from other interfaces.
	IsDefineClassStmtContext()
}

type DefineClassStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	className IDeclIdentifierContext
}

func NewEmptyDefineClassStmtContext() *DefineClassStmtContext {
	var p = new(DefineClassStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineClassStmt
	return p
}

func InitEmptyDefineClassStmtContext(p *DefineClassStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineClassStmt
}

func (*DefineClassStmtContext) IsDefineClassStmtContext() {}

func NewDefineClassStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineClassStmtContext {
	var p = new(DefineClassStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_defineClassStmt

	return p
}

func (s *DefineClassStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineClassStmtContext) GetClassName() IDeclIdentifierContext { return s.className }

func (s *DefineClassStmtContext) SetClassName(v IDeclIdentifierContext) { s.className = v }

func (s *DefineClassStmtContext) CLASS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserCLASS, 0)
}

func (s *DefineClassStmtContext) AllClassStmt() []IClassStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassStmtContext); ok {
			len++
		}
	}

	tst := make([]IClassStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassStmtContext); ok {
			tst[i] = t.(IClassStmtContext)
			i++
		}
	}

	return tst
}

func (s *DefineClassStmtContext) ClassStmt(i int) IClassStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassStmtContext)
}

func (s *DefineClassStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *DefineClassStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *DefineClassStmtContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *DefineClassStmtContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *DefineClassStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineClassStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineClassStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDefineClassStmt(s)
	}
}

func (s *DefineClassStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDefineClassStmt(s)
	}
}

func (p *JetRuleParser) DefineClassStmt() (localctx IDefineClassStmtContext) {
	localctx = NewDefineClassStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, JetRuleParserRULE_defineClassStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(207)
		p.Match(JetRuleParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(208)

		var _x = p.DeclIdentifier()

		localctx.(*DefineClassStmtContext).className = _x
	}
	{
		p.SetState(209)
		p.Match(JetRuleParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(210)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(216)
		p.ClassStmt()
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserT__2 {
		{
			p.SetState(217)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(218)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(223)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(224)
			p.ClassStmt()
		}

		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(230)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(236)
		p.Match(JetRuleParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(237)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassStmtContext is an interface to support dynamic dispatch.
type IClassStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseClasses() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	AllSubClassOfStmt() []ISubClassOfStmtContext
	SubClassOfStmt(i int) ISubClassOfStmtContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode
	DataProperties() antlr.TerminalNode
	AllDataPropertyDefinitions() []IDataPropertyDefinitionsContext
	DataPropertyDefinitions(i int) IDataPropertyDefinitionsContext
	GroupingProperties() antlr.TerminalNode
	AllGroupingPropertyStmt() []IGroupingPropertyStmtContext
	GroupingPropertyStmt(i int) IGroupingPropertyStmtContext
	AsTableStmt() IAsTableStmtContext

	// IsClassStmtContext differentiates from other interfaces.
	IsClassStmtContext()
}

type ClassStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStmtContext() *ClassStmtContext {
	var p = new(ClassStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_classStmt
	return p
}

func InitEmptyClassStmtContext(p *ClassStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_classStmt
}

func (*ClassStmtContext) IsClassStmtContext() {}

func NewClassStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStmtContext {
	var p = new(ClassStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_classStmt

	return p
}

func (s *ClassStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStmtContext) BaseClasses() antlr.TerminalNode {
	return s.GetToken(JetRuleParserBaseClasses, 0)
}

func (s *ClassStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *ClassStmtContext) AllSubClassOfStmt() []ISubClassOfStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubClassOfStmtContext); ok {
			len++
		}
	}

	tst := make([]ISubClassOfStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubClassOfStmtContext); ok {
			tst[i] = t.(ISubClassOfStmtContext)
			i++
		}
	}

	return tst
}

func (s *ClassStmtContext) SubClassOfStmt(i int) ISubClassOfStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubClassOfStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubClassOfStmtContext)
}

func (s *ClassStmtContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *ClassStmtContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *ClassStmtContext) DataProperties() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDataProperties, 0)
}

func (s *ClassStmtContext) AllDataPropertyDefinitions() []IDataPropertyDefinitionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataPropertyDefinitionsContext); ok {
			len++
		}
	}

	tst := make([]IDataPropertyDefinitionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataPropertyDefinitionsContext); ok {
			tst[i] = t.(IDataPropertyDefinitionsContext)
			i++
		}
	}

	return tst
}

func (s *ClassStmtContext) DataPropertyDefinitions(i int) IDataPropertyDefinitionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataPropertyDefinitionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataPropertyDefinitionsContext)
}

func (s *ClassStmtContext) GroupingProperties() antlr.TerminalNode {
	return s.GetToken(JetRuleParserGroupingProperties, 0)
}

func (s *ClassStmtContext) AllGroupingPropertyStmt() []IGroupingPropertyStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingPropertyStmtContext); ok {
			len++
		}
	}

	tst := make([]IGroupingPropertyStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingPropertyStmtContext); ok {
			tst[i] = t.(IGroupingPropertyStmtContext)
			i++
		}
	}

	return tst
}

func (s *ClassStmtContext) GroupingPropertyStmt(i int) IGroupingPropertyStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingPropertyStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingPropertyStmtContext)
}

func (s *ClassStmtContext) AsTableStmt() IAsTableStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsTableStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsTableStmtContext)
}

func (s *ClassStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterClassStmt(s)
	}
}

func (s *ClassStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitClassStmt(s)
	}
}

func (p *JetRuleParser) ClassStmt() (localctx IClassStmtContext) {
	localctx = NewClassStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, JetRuleParserRULE_classStmt)
	var _la int

	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserBaseClasses:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(239)
			p.Match(JetRuleParserBaseClasses)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(240)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)
			p.Match(JetRuleParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(242)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(247)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(248)
			p.SubClassOfStmt()
		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserT__2 {
			{
				p.SetState(249)
				p.Match(JetRuleParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == JetRuleParserCOMMENT {
				{
					p.SetState(250)
					p.Match(JetRuleParserCOMMENT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(255)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(256)
				p.SubClassOfStmt()
			}

			p.SetState(261)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(262)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(267)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(268)
			p.Match(JetRuleParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserDataProperties:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(270)
			p.Match(JetRuleParserDataProperties)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(271)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(272)
			p.Match(JetRuleParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(273)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(278)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(279)
			p.DataPropertyDefinitions()
		}
		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserT__2 {
			{
				p.SetState(280)
				p.Match(JetRuleParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(284)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == JetRuleParserCOMMENT {
				{
					p.SetState(281)
					p.Match(JetRuleParserCOMMENT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(286)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(287)
				p.DataPropertyDefinitions()
			}

			p.SetState(292)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(296)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(293)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(298)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(299)
			p.Match(JetRuleParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserGroupingProperties:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(301)
			p.Match(JetRuleParserGroupingProperties)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(302)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(303)
			p.Match(JetRuleParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(304)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(309)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(310)
			p.GroupingPropertyStmt()
		}
		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserT__2 {
			{
				p.SetState(311)
				p.Match(JetRuleParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(315)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == JetRuleParserCOMMENT {
				{
					p.SetState(312)
					p.Match(JetRuleParserCOMMENT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(317)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(318)
				p.GroupingPropertyStmt()
			}

			p.SetState(323)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(324)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(330)
			p.Match(JetRuleParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserAsTable:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(332)
			p.AsTableStmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubClassOfStmtContext is an interface to support dynamic dispatch.
type ISubClassOfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBaseClassName returns the baseClassName rule contexts.
	GetBaseClassName() IDeclIdentifierContext

	// SetBaseClassName sets the baseClassName rule contexts.
	SetBaseClassName(IDeclIdentifierContext)

	// Getter signatures
	DeclIdentifier() IDeclIdentifierContext

	// IsSubClassOfStmtContext differentiates from other interfaces.
	IsSubClassOfStmtContext()
}

type SubClassOfStmtContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	baseClassName IDeclIdentifierContext
}

func NewEmptySubClassOfStmtContext() *SubClassOfStmtContext {
	var p = new(SubClassOfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_subClassOfStmt
	return p
}

func InitEmptySubClassOfStmtContext(p *SubClassOfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_subClassOfStmt
}

func (*SubClassOfStmtContext) IsSubClassOfStmtContext() {}

func NewSubClassOfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubClassOfStmtContext {
	var p = new(SubClassOfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_subClassOfStmt

	return p
}

func (s *SubClassOfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SubClassOfStmtContext) GetBaseClassName() IDeclIdentifierContext { return s.baseClassName }

func (s *SubClassOfStmtContext) SetBaseClassName(v IDeclIdentifierContext) { s.baseClassName = v }

func (s *SubClassOfStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *SubClassOfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubClassOfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubClassOfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterSubClassOfStmt(s)
	}
}

func (s *SubClassOfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitSubClassOfStmt(s)
	}
}

func (p *JetRuleParser) SubClassOfStmt() (localctx ISubClassOfStmtContext) {
	localctx = NewSubClassOfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, JetRuleParserRULE_subClassOfStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)

		var _x = p.DeclIdentifier()

		localctx.(*SubClassOfStmtContext).baseClassName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataPropertyDefinitionsContext is an interface to support dynamic dispatch.
type IDataPropertyDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetArray returns the array token.
	GetArray() antlr.Token

	// SetArray sets the array token.
	SetArray(antlr.Token)

	// GetDataPName returns the dataPName rule contexts.
	GetDataPName() IDeclIdentifierContext

	// GetDataPType returns the dataPType rule contexts.
	GetDataPType() IDataPropertyTypeContext

	// SetDataPName sets the dataPName rule contexts.
	SetDataPName(IDeclIdentifierContext)

	// SetDataPType sets the dataPType rule contexts.
	SetDataPType(IDataPropertyTypeContext)

	// Getter signatures
	DeclIdentifier() IDeclIdentifierContext
	DataPropertyType() IDataPropertyTypeContext
	ARRAY() antlr.TerminalNode

	// IsDataPropertyDefinitionsContext differentiates from other interfaces.
	IsDataPropertyDefinitionsContext()
}

type DataPropertyDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	dataPName IDeclIdentifierContext
	array     antlr.Token
	dataPType IDataPropertyTypeContext
}

func NewEmptyDataPropertyDefinitionsContext() *DataPropertyDefinitionsContext {
	var p = new(DataPropertyDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_dataPropertyDefinitions
	return p
}

func InitEmptyDataPropertyDefinitionsContext(p *DataPropertyDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_dataPropertyDefinitions
}

func (*DataPropertyDefinitionsContext) IsDataPropertyDefinitionsContext() {}

func NewDataPropertyDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataPropertyDefinitionsContext {
	var p = new(DataPropertyDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_dataPropertyDefinitions

	return p
}

func (s *DataPropertyDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DataPropertyDefinitionsContext) GetArray() antlr.Token { return s.array }

func (s *DataPropertyDefinitionsContext) SetArray(v antlr.Token) { s.array = v }

func (s *DataPropertyDefinitionsContext) GetDataPName() IDeclIdentifierContext { return s.dataPName }

func (s *DataPropertyDefinitionsContext) GetDataPType() IDataPropertyTypeContext { return s.dataPType }

func (s *DataPropertyDefinitionsContext) SetDataPName(v IDeclIdentifierContext) { s.dataPName = v }

func (s *DataPropertyDefinitionsContext) SetDataPType(v IDataPropertyTypeContext) { s.dataPType = v }

func (s *DataPropertyDefinitionsContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *DataPropertyDefinitionsContext) DataPropertyType() IDataPropertyTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataPropertyTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataPropertyTypeContext)
}

func (s *DataPropertyDefinitionsContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(JetRuleParserARRAY, 0)
}

func (s *DataPropertyDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataPropertyDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataPropertyDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDataPropertyDefinitions(s)
	}
}

func (s *DataPropertyDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDataPropertyDefinitions(s)
	}
}

func (p *JetRuleParser) DataPropertyDefinitions() (localctx IDataPropertyDefinitionsContext) {
	localctx = NewDataPropertyDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, JetRuleParserRULE_dataPropertyDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)

		var _x = p.DeclIdentifier()

		localctx.(*DataPropertyDefinitionsContext).dataPName = _x
	}
	{
		p.SetState(338)
		p.Match(JetRuleParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserARRAY {
		{
			p.SetState(339)

			var _m = p.Match(JetRuleParserARRAY)

			localctx.(*DataPropertyDefinitionsContext).array = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(342)

		var _x = p.DataPropertyType()

		localctx.(*DataPropertyDefinitionsContext).dataPType = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataPropertyTypeContext is an interface to support dynamic dispatch.
type IDataPropertyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Int32Type() antlr.TerminalNode
	UInt32Type() antlr.TerminalNode
	Int64Type() antlr.TerminalNode
	UInt64Type() antlr.TerminalNode
	DoubleType() antlr.TerminalNode
	StringType() antlr.TerminalNode
	DateType() antlr.TerminalNode
	DatetimeType() antlr.TerminalNode
	BoolType() antlr.TerminalNode
	ResourceType() antlr.TerminalNode

	// IsDataPropertyTypeContext differentiates from other interfaces.
	IsDataPropertyTypeContext()
}

type DataPropertyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataPropertyTypeContext() *DataPropertyTypeContext {
	var p = new(DataPropertyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_dataPropertyType
	return p
}

func InitEmptyDataPropertyTypeContext(p *DataPropertyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_dataPropertyType
}

func (*DataPropertyTypeContext) IsDataPropertyTypeContext() {}

func NewDataPropertyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataPropertyTypeContext {
	var p = new(DataPropertyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_dataPropertyType

	return p
}

func (s *DataPropertyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataPropertyTypeContext) Int32Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInt32Type, 0)
}

func (s *DataPropertyTypeContext) UInt32Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserUInt32Type, 0)
}

func (s *DataPropertyTypeContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInt64Type, 0)
}

func (s *DataPropertyTypeContext) UInt64Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserUInt64Type, 0)
}

func (s *DataPropertyTypeContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDoubleType, 0)
}

func (s *DataPropertyTypeContext) StringType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserStringType, 0)
}

func (s *DataPropertyTypeContext) DateType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDateType, 0)
}

func (s *DataPropertyTypeContext) DatetimeType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDatetimeType, 0)
}

func (s *DataPropertyTypeContext) BoolType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserBoolType, 0)
}

func (s *DataPropertyTypeContext) ResourceType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserResourceType, 0)
}

func (s *DataPropertyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataPropertyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataPropertyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDataPropertyType(s)
	}
}

func (s *DataPropertyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDataPropertyType(s)
	}
}

func (p *JetRuleParser) DataPropertyType() (localctx IDataPropertyTypeContext) {
	localctx = NewDataPropertyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, JetRuleParserRULE_dataPropertyType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(344)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&274609471488) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingPropertyStmtContext is an interface to support dynamic dispatch.
type IGroupingPropertyStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetGroupingPropertyName returns the groupingPropertyName rule contexts.
	GetGroupingPropertyName() IDeclIdentifierContext

	// SetGroupingPropertyName sets the groupingPropertyName rule contexts.
	SetGroupingPropertyName(IDeclIdentifierContext)

	// Getter signatures
	DeclIdentifier() IDeclIdentifierContext

	// IsGroupingPropertyStmtContext differentiates from other interfaces.
	IsGroupingPropertyStmtContext()
}

type GroupingPropertyStmtContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	groupingPropertyName IDeclIdentifierContext
}

func NewEmptyGroupingPropertyStmtContext() *GroupingPropertyStmtContext {
	var p = new(GroupingPropertyStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_groupingPropertyStmt
	return p
}

func InitEmptyGroupingPropertyStmtContext(p *GroupingPropertyStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_groupingPropertyStmt
}

func (*GroupingPropertyStmtContext) IsGroupingPropertyStmtContext() {}

func NewGroupingPropertyStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingPropertyStmtContext {
	var p = new(GroupingPropertyStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_groupingPropertyStmt

	return p
}

func (s *GroupingPropertyStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingPropertyStmtContext) GetGroupingPropertyName() IDeclIdentifierContext {
	return s.groupingPropertyName
}

func (s *GroupingPropertyStmtContext) SetGroupingPropertyName(v IDeclIdentifierContext) {
	s.groupingPropertyName = v
}

func (s *GroupingPropertyStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *GroupingPropertyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingPropertyStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingPropertyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterGroupingPropertyStmt(s)
	}
}

func (s *GroupingPropertyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitGroupingPropertyStmt(s)
	}
}

func (p *JetRuleParser) GroupingPropertyStmt() (localctx IGroupingPropertyStmtContext) {
	localctx = NewGroupingPropertyStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, JetRuleParserRULE_groupingPropertyStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)

		var _x = p.DeclIdentifier()

		localctx.(*GroupingPropertyStmtContext).groupingPropertyName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsTableStmtContext is an interface to support dynamic dispatch.
type IAsTableStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAsTable returns the asTable rule contexts.
	GetAsTable() IAsTableFlagContext

	// SetAsTable sets the asTable rule contexts.
	SetAsTable(IAsTableFlagContext)

	// Getter signatures
	AsTable() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	AsTableFlag() IAsTableFlagContext

	// IsAsTableStmtContext differentiates from other interfaces.
	IsAsTableStmtContext()
}

type AsTableStmtContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	asTable IAsTableFlagContext
}

func NewEmptyAsTableStmtContext() *AsTableStmtContext {
	var p = new(AsTableStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_asTableStmt
	return p
}

func InitEmptyAsTableStmtContext(p *AsTableStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_asTableStmt
}

func (*AsTableStmtContext) IsAsTableStmtContext() {}

func NewAsTableStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsTableStmtContext {
	var p = new(AsTableStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_asTableStmt

	return p
}

func (s *AsTableStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AsTableStmtContext) GetAsTable() IAsTableFlagContext { return s.asTable }

func (s *AsTableStmtContext) SetAsTable(v IAsTableFlagContext) { s.asTable = v }

func (s *AsTableStmtContext) AsTable() antlr.TerminalNode {
	return s.GetToken(JetRuleParserAsTable, 0)
}

func (s *AsTableStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *AsTableStmtContext) AsTableFlag() IAsTableFlagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsTableFlagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsTableFlagContext)
}

func (s *AsTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsTableStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterAsTableStmt(s)
	}
}

func (s *AsTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitAsTableStmt(s)
	}
}

func (p *JetRuleParser) AsTableStmt() (localctx IAsTableStmtContext) {
	localctx = NewAsTableStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, JetRuleParserRULE_asTableStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)
		p.Match(JetRuleParserAsTable)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(349)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(350)

		var _x = p.AsTableFlag()

		localctx.(*AsTableStmtContext).asTable = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsTableFlagContext is an interface to support dynamic dispatch.
type IAsTableFlagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsAsTableFlagContext differentiates from other interfaces.
	IsAsTableFlagContext()
}

type AsTableFlagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsTableFlagContext() *AsTableFlagContext {
	var p = new(AsTableFlagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_asTableFlag
	return p
}

func InitEmptyAsTableFlagContext(p *AsTableFlagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_asTableFlag
}

func (*AsTableFlagContext) IsAsTableFlagContext() {}

func NewAsTableFlagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsTableFlagContext {
	var p = new(AsTableFlagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_asTableFlag

	return p
}

func (s *AsTableFlagContext) GetParser() antlr.Parser { return s.parser }

func (s *AsTableFlagContext) TRUE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserTRUE, 0)
}

func (s *AsTableFlagContext) FALSE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserFALSE, 0)
}

func (s *AsTableFlagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsTableFlagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsTableFlagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterAsTableFlag(s)
	}
}

func (s *AsTableFlagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitAsTableFlag(s)
	}
}

func (p *JetRuleParser) AsTableFlag() (localctx IAsTableFlagContext) {
	localctx = NewAsTableFlagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, JetRuleParserRULE_asTableFlag)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(352)
		_la = p.GetTokenStream().LA(1)

		if !(_la == JetRuleParserTRUE || _la == JetRuleParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefineRuleSeqStmtContext is an interface to support dynamic dispatch.
type IDefineRuleSeqStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRuleseqName returns the ruleseqName token.
	GetRuleseqName() antlr.Token

	// SetRuleseqName sets the ruleseqName token.
	SetRuleseqName(antlr.Token)

	// Getter signatures
	RULESEQ() antlr.TerminalNode
	MainRuleSets() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	RuleSetSeq() IRuleSetSeqContext
	SEMICOLON() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsDefineRuleSeqStmtContext differentiates from other interfaces.
	IsDefineRuleSeqStmtContext()
}

type DefineRuleSeqStmtContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	ruleseqName antlr.Token
}

func NewEmptyDefineRuleSeqStmtContext() *DefineRuleSeqStmtContext {
	var p = new(DefineRuleSeqStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineRuleSeqStmt
	return p
}

func InitEmptyDefineRuleSeqStmtContext(p *DefineRuleSeqStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineRuleSeqStmt
}

func (*DefineRuleSeqStmtContext) IsDefineRuleSeqStmtContext() {}

func NewDefineRuleSeqStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineRuleSeqStmtContext {
	var p = new(DefineRuleSeqStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_defineRuleSeqStmt

	return p
}

func (s *DefineRuleSeqStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineRuleSeqStmtContext) GetRuleseqName() antlr.Token { return s.ruleseqName }

func (s *DefineRuleSeqStmtContext) SetRuleseqName(v antlr.Token) { s.ruleseqName = v }

func (s *DefineRuleSeqStmtContext) RULESEQ() antlr.TerminalNode {
	return s.GetToken(JetRuleParserRULESEQ, 0)
}

func (s *DefineRuleSeqStmtContext) MainRuleSets() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMainRuleSets, 0)
}

func (s *DefineRuleSeqStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *DefineRuleSeqStmtContext) RuleSetSeq() IRuleSetSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetSeqContext)
}

func (s *DefineRuleSeqStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *DefineRuleSeqStmtContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, 0)
}

func (s *DefineRuleSeqStmtContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *DefineRuleSeqStmtContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *DefineRuleSeqStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineRuleSeqStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineRuleSeqStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDefineRuleSeqStmt(s)
	}
}

func (s *DefineRuleSeqStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDefineRuleSeqStmt(s)
	}
}

func (p *JetRuleParser) DefineRuleSeqStmt() (localctx IDefineRuleSeqStmtContext) {
	localctx = NewDefineRuleSeqStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, JetRuleParserRULE_defineRuleSeqStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(JetRuleParserRULESEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(355)

		var _m = p.Match(JetRuleParserIdentifier)

		localctx.(*DefineRuleSeqStmtContext).ruleseqName = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(356)
		p.Match(JetRuleParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(357)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(363)
		p.Match(JetRuleParserMainRuleSets)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(364)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(365)
		p.Match(JetRuleParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(366)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(372)
		p.RuleSetSeq()
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(373)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(379)
		p.Match(JetRuleParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserT__2 {
		{
			p.SetState(380)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(383)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(389)
		p.Match(JetRuleParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(390)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRuleSetSeqContext is an interface to support dynamic dispatch.
type IRuleSetSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRuleSetDefinitions() []IRuleSetDefinitionsContext
	RuleSetDefinitions(i int) IRuleSetDefinitionsContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsRuleSetSeqContext differentiates from other interfaces.
	IsRuleSetSeqContext()
}

type RuleSetSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetSeqContext() *RuleSetSeqContext {
	var p = new(RuleSetSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_ruleSetSeq
	return p
}

func InitEmptyRuleSetSeqContext(p *RuleSetSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_ruleSetSeq
}

func (*RuleSetSeqContext) IsRuleSetSeqContext() {}

func NewRuleSetSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetSeqContext {
	var p = new(RuleSetSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_ruleSetSeq

	return p
}

func (s *RuleSetSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetSeqContext) AllRuleSetDefinitions() []IRuleSetDefinitionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRuleSetDefinitionsContext); ok {
			len++
		}
	}

	tst := make([]IRuleSetDefinitionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRuleSetDefinitionsContext); ok {
			tst[i] = t.(IRuleSetDefinitionsContext)
			i++
		}
	}

	return tst
}

func (s *RuleSetSeqContext) RuleSetDefinitions(i int) IRuleSetDefinitionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetDefinitionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetDefinitionsContext)
}

func (s *RuleSetSeqContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *RuleSetSeqContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *RuleSetSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterRuleSetSeq(s)
	}
}

func (s *RuleSetSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitRuleSetSeq(s)
	}
}

func (p *JetRuleParser) RuleSetSeq() (localctx IRuleSetSeqContext) {
	localctx = NewRuleSetSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, JetRuleParserRULE_ruleSetSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.RuleSetDefinitions()
	}
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserT__2 {
		{
			p.SetState(393)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(394)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(400)
			p.RuleSetDefinitions()
		}

		p.SetState(405)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRuleSetDefinitionsContext is an interface to support dynamic dispatch.
type IRuleSetDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRsName returns the rsName token.
	GetRsName() antlr.Token

	// SetRsName sets the rsName token.
	SetRsName(antlr.Token)

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsRuleSetDefinitionsContext differentiates from other interfaces.
	IsRuleSetDefinitionsContext()
}

type RuleSetDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rsName antlr.Token
}

func NewEmptyRuleSetDefinitionsContext() *RuleSetDefinitionsContext {
	var p = new(RuleSetDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_ruleSetDefinitions
	return p
}

func InitEmptyRuleSetDefinitionsContext(p *RuleSetDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_ruleSetDefinitions
}

func (*RuleSetDefinitionsContext) IsRuleSetDefinitionsContext() {}

func NewRuleSetDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetDefinitionsContext {
	var p = new(RuleSetDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_ruleSetDefinitions

	return p
}

func (s *RuleSetDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetDefinitionsContext) GetRsName() antlr.Token { return s.rsName }

func (s *RuleSetDefinitionsContext) SetRsName(v antlr.Token) { s.rsName = v }

func (s *RuleSetDefinitionsContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *RuleSetDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterRuleSetDefinitions(s)
	}
}

func (s *RuleSetDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitRuleSetDefinitions(s)
	}
}

func (p *JetRuleParser) RuleSetDefinitions() (localctx IRuleSetDefinitionsContext) {
	localctx = NewRuleSetDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, JetRuleParserRULE_ruleSetDefinitions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*RuleSetDefinitionsContext).rsName = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefineLiteralStmtContext is an interface to support dynamic dispatch.
type IDefineLiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Int32LiteralStmt() IInt32LiteralStmtContext
	UInt32LiteralStmt() IUInt32LiteralStmtContext
	Int64LiteralStmt() IInt64LiteralStmtContext
	UInt64LiteralStmt() IUInt64LiteralStmtContext
	DoubleLiteralStmt() IDoubleLiteralStmtContext
	StringLiteralStmt() IStringLiteralStmtContext
	DateLiteralStmt() IDateLiteralStmtContext
	DatetimeLiteralStmt() IDatetimeLiteralStmtContext
	BooleanLiteralStmt() IBooleanLiteralStmtContext

	// IsDefineLiteralStmtContext differentiates from other interfaces.
	IsDefineLiteralStmtContext()
}

type DefineLiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefineLiteralStmtContext() *DefineLiteralStmtContext {
	var p = new(DefineLiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineLiteralStmt
	return p
}

func InitEmptyDefineLiteralStmtContext(p *DefineLiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineLiteralStmt
}

func (*DefineLiteralStmtContext) IsDefineLiteralStmtContext() {}

func NewDefineLiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineLiteralStmtContext {
	var p = new(DefineLiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_defineLiteralStmt

	return p
}

func (s *DefineLiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineLiteralStmtContext) Int32LiteralStmt() IInt32LiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt32LiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt32LiteralStmtContext)
}

func (s *DefineLiteralStmtContext) UInt32LiteralStmt() IUInt32LiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUInt32LiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUInt32LiteralStmtContext)
}

func (s *DefineLiteralStmtContext) Int64LiteralStmt() IInt64LiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt64LiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt64LiteralStmtContext)
}

func (s *DefineLiteralStmtContext) UInt64LiteralStmt() IUInt64LiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUInt64LiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUInt64LiteralStmtContext)
}

func (s *DefineLiteralStmtContext) DoubleLiteralStmt() IDoubleLiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleLiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleLiteralStmtContext)
}

func (s *DefineLiteralStmtContext) StringLiteralStmt() IStringLiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralStmtContext)
}

func (s *DefineLiteralStmtContext) DateLiteralStmt() IDateLiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateLiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateLiteralStmtContext)
}

func (s *DefineLiteralStmtContext) DatetimeLiteralStmt() IDatetimeLiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeLiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeLiteralStmtContext)
}

func (s *DefineLiteralStmtContext) BooleanLiteralStmt() IBooleanLiteralStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralStmtContext)
}

func (s *DefineLiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineLiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineLiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDefineLiteralStmt(s)
	}
}

func (s *DefineLiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDefineLiteralStmt(s)
	}
}

func (p *JetRuleParser) DefineLiteralStmt() (localctx IDefineLiteralStmtContext) {
	localctx = NewDefineLiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, JetRuleParserRULE_defineLiteralStmt)
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserInt32Type:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(408)
			p.Int32LiteralStmt()
		}

	case JetRuleParserUInt32Type:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(409)
			p.UInt32LiteralStmt()
		}

	case JetRuleParserInt64Type:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(410)
			p.Int64LiteralStmt()
		}

	case JetRuleParserUInt64Type:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(411)
			p.UInt64LiteralStmt()
		}

	case JetRuleParserDoubleType:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(412)
			p.DoubleLiteralStmt()
		}

	case JetRuleParserStringType:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(413)
			p.StringLiteralStmt()
		}

	case JetRuleParserDateType:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(414)
			p.DateLiteralStmt()
		}

	case JetRuleParserDatetimeType:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(415)
			p.DatetimeLiteralStmt()
		}

	case JetRuleParserBoolType:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(416)
			p.BooleanLiteralStmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInt32LiteralStmtContext is an interface to support dynamic dispatch.
type IInt32LiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// GetDeclValue returns the declValue rule contexts.
	GetDeclValue() IIntExprContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// SetDeclValue sets the declValue rule contexts.
	SetDeclValue(IIntExprContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	Int32Type() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	IntExpr() IIntExprContext

	// IsInt32LiteralStmtContext differentiates from other interfaces.
	IsInt32LiteralStmtContext()
}

type Int32LiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue IIntExprContext
}

func NewEmptyInt32LiteralStmtContext() *Int32LiteralStmtContext {
	var p = new(Int32LiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_int32LiteralStmt
	return p
}

func InitEmptyInt32LiteralStmtContext(p *Int32LiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_int32LiteralStmt
}

func (*Int32LiteralStmtContext) IsInt32LiteralStmtContext() {}

func NewInt32LiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int32LiteralStmtContext {
	var p = new(Int32LiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_int32LiteralStmt

	return p
}

func (s *Int32LiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Int32LiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *Int32LiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *Int32LiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *Int32LiteralStmtContext) GetDeclValue() IIntExprContext { return s.declValue }

func (s *Int32LiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *Int32LiteralStmtContext) SetDeclValue(v IIntExprContext) { s.declValue = v }

func (s *Int32LiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *Int32LiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *Int32LiteralStmtContext) Int32Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInt32Type, 0)
}

func (s *Int32LiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *Int32LiteralStmtContext) IntExpr() IIntExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntExprContext)
}

func (s *Int32LiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int32LiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int32LiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterInt32LiteralStmt(s)
	}
}

func (s *Int32LiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitInt32LiteralStmt(s)
	}
}

func (p *JetRuleParser) Int32LiteralStmt() (localctx IInt32LiteralStmtContext) {
	localctx = NewInt32LiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, JetRuleParserRULE_int32LiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)

		var _m = p.Match(JetRuleParserInt32Type)

		localctx.(*Int32LiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(420)

		var _x = p.DeclIdentifier()

		localctx.(*Int32LiteralStmtContext).varName = _x
	}
	{
		p.SetState(421)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(422)

		var _x = p.IntExpr()

		localctx.(*Int32LiteralStmtContext).declValue = _x
	}
	{
		p.SetState(423)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUInt32LiteralStmtContext is an interface to support dynamic dispatch.
type IUInt32LiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// GetDeclValue returns the declValue rule contexts.
	GetDeclValue() IUintExprContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// SetDeclValue sets the declValue rule contexts.
	SetDeclValue(IUintExprContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	UInt32Type() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	UintExpr() IUintExprContext

	// IsUInt32LiteralStmtContext differentiates from other interfaces.
	IsUInt32LiteralStmtContext()
}

type UInt32LiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue IUintExprContext
}

func NewEmptyUInt32LiteralStmtContext() *UInt32LiteralStmtContext {
	var p = new(UInt32LiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_uInt32LiteralStmt
	return p
}

func InitEmptyUInt32LiteralStmtContext(p *UInt32LiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_uInt32LiteralStmt
}

func (*UInt32LiteralStmtContext) IsUInt32LiteralStmtContext() {}

func NewUInt32LiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UInt32LiteralStmtContext {
	var p = new(UInt32LiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_uInt32LiteralStmt

	return p
}

func (s *UInt32LiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *UInt32LiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *UInt32LiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *UInt32LiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *UInt32LiteralStmtContext) GetDeclValue() IUintExprContext { return s.declValue }

func (s *UInt32LiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *UInt32LiteralStmtContext) SetDeclValue(v IUintExprContext) { s.declValue = v }

func (s *UInt32LiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *UInt32LiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *UInt32LiteralStmtContext) UInt32Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserUInt32Type, 0)
}

func (s *UInt32LiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *UInt32LiteralStmtContext) UintExpr() IUintExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUintExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUintExprContext)
}

func (s *UInt32LiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UInt32LiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UInt32LiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUInt32LiteralStmt(s)
	}
}

func (s *UInt32LiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUInt32LiteralStmt(s)
	}
}

func (p *JetRuleParser) UInt32LiteralStmt() (localctx IUInt32LiteralStmtContext) {
	localctx = NewUInt32LiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, JetRuleParserRULE_uInt32LiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)

		var _m = p.Match(JetRuleParserUInt32Type)

		localctx.(*UInt32LiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(426)

		var _x = p.DeclIdentifier()

		localctx.(*UInt32LiteralStmtContext).varName = _x
	}
	{
		p.SetState(427)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(428)

		var _x = p.UintExpr()

		localctx.(*UInt32LiteralStmtContext).declValue = _x
	}
	{
		p.SetState(429)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInt64LiteralStmtContext is an interface to support dynamic dispatch.
type IInt64LiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// GetDeclValue returns the declValue rule contexts.
	GetDeclValue() IIntExprContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// SetDeclValue sets the declValue rule contexts.
	SetDeclValue(IIntExprContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	Int64Type() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	IntExpr() IIntExprContext

	// IsInt64LiteralStmtContext differentiates from other interfaces.
	IsInt64LiteralStmtContext()
}

type Int64LiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue IIntExprContext
}

func NewEmptyInt64LiteralStmtContext() *Int64LiteralStmtContext {
	var p = new(Int64LiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_int64LiteralStmt
	return p
}

func InitEmptyInt64LiteralStmtContext(p *Int64LiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_int64LiteralStmt
}

func (*Int64LiteralStmtContext) IsInt64LiteralStmtContext() {}

func NewInt64LiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int64LiteralStmtContext {
	var p = new(Int64LiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_int64LiteralStmt

	return p
}

func (s *Int64LiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Int64LiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *Int64LiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *Int64LiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *Int64LiteralStmtContext) GetDeclValue() IIntExprContext { return s.declValue }

func (s *Int64LiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *Int64LiteralStmtContext) SetDeclValue(v IIntExprContext) { s.declValue = v }

func (s *Int64LiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *Int64LiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *Int64LiteralStmtContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInt64Type, 0)
}

func (s *Int64LiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *Int64LiteralStmtContext) IntExpr() IIntExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntExprContext)
}

func (s *Int64LiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int64LiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int64LiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterInt64LiteralStmt(s)
	}
}

func (s *Int64LiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitInt64LiteralStmt(s)
	}
}

func (p *JetRuleParser) Int64LiteralStmt() (localctx IInt64LiteralStmtContext) {
	localctx = NewInt64LiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, JetRuleParserRULE_int64LiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)

		var _m = p.Match(JetRuleParserInt64Type)

		localctx.(*Int64LiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(432)

		var _x = p.DeclIdentifier()

		localctx.(*Int64LiteralStmtContext).varName = _x
	}
	{
		p.SetState(433)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(434)

		var _x = p.IntExpr()

		localctx.(*Int64LiteralStmtContext).declValue = _x
	}
	{
		p.SetState(435)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUInt64LiteralStmtContext is an interface to support dynamic dispatch.
type IUInt64LiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// GetDeclValue returns the declValue rule contexts.
	GetDeclValue() IUintExprContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// SetDeclValue sets the declValue rule contexts.
	SetDeclValue(IUintExprContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	UInt64Type() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	UintExpr() IUintExprContext

	// IsUInt64LiteralStmtContext differentiates from other interfaces.
	IsUInt64LiteralStmtContext()
}

type UInt64LiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue IUintExprContext
}

func NewEmptyUInt64LiteralStmtContext() *UInt64LiteralStmtContext {
	var p = new(UInt64LiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_uInt64LiteralStmt
	return p
}

func InitEmptyUInt64LiteralStmtContext(p *UInt64LiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_uInt64LiteralStmt
}

func (*UInt64LiteralStmtContext) IsUInt64LiteralStmtContext() {}

func NewUInt64LiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UInt64LiteralStmtContext {
	var p = new(UInt64LiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_uInt64LiteralStmt

	return p
}

func (s *UInt64LiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *UInt64LiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *UInt64LiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *UInt64LiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *UInt64LiteralStmtContext) GetDeclValue() IUintExprContext { return s.declValue }

func (s *UInt64LiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *UInt64LiteralStmtContext) SetDeclValue(v IUintExprContext) { s.declValue = v }

func (s *UInt64LiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *UInt64LiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *UInt64LiteralStmtContext) UInt64Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserUInt64Type, 0)
}

func (s *UInt64LiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *UInt64LiteralStmtContext) UintExpr() IUintExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUintExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUintExprContext)
}

func (s *UInt64LiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UInt64LiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UInt64LiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUInt64LiteralStmt(s)
	}
}

func (s *UInt64LiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUInt64LiteralStmt(s)
	}
}

func (p *JetRuleParser) UInt64LiteralStmt() (localctx IUInt64LiteralStmtContext) {
	localctx = NewUInt64LiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, JetRuleParserRULE_uInt64LiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)

		var _m = p.Match(JetRuleParserUInt64Type)

		localctx.(*UInt64LiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(438)

		var _x = p.DeclIdentifier()

		localctx.(*UInt64LiteralStmtContext).varName = _x
	}
	{
		p.SetState(439)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(440)

		var _x = p.UintExpr()

		localctx.(*UInt64LiteralStmtContext).declValue = _x
	}
	{
		p.SetState(441)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleLiteralStmtContext is an interface to support dynamic dispatch.
type IDoubleLiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// GetDeclValue returns the declValue rule contexts.
	GetDeclValue() IDoubleExprContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// SetDeclValue sets the declValue rule contexts.
	SetDeclValue(IDoubleExprContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	DoubleType() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	DoubleExpr() IDoubleExprContext

	// IsDoubleLiteralStmtContext differentiates from other interfaces.
	IsDoubleLiteralStmtContext()
}

type DoubleLiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue IDoubleExprContext
}

func NewEmptyDoubleLiteralStmtContext() *DoubleLiteralStmtContext {
	var p = new(DoubleLiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_doubleLiteralStmt
	return p
}

func InitEmptyDoubleLiteralStmtContext(p *DoubleLiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_doubleLiteralStmt
}

func (*DoubleLiteralStmtContext) IsDoubleLiteralStmtContext() {}

func NewDoubleLiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleLiteralStmtContext {
	var p = new(DoubleLiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_doubleLiteralStmt

	return p
}

func (s *DoubleLiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleLiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *DoubleLiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *DoubleLiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *DoubleLiteralStmtContext) GetDeclValue() IDoubleExprContext { return s.declValue }

func (s *DoubleLiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *DoubleLiteralStmtContext) SetDeclValue(v IDoubleExprContext) { s.declValue = v }

func (s *DoubleLiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *DoubleLiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *DoubleLiteralStmtContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDoubleType, 0)
}

func (s *DoubleLiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *DoubleLiteralStmtContext) DoubleExpr() IDoubleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleExprContext)
}

func (s *DoubleLiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleLiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleLiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDoubleLiteralStmt(s)
	}
}

func (s *DoubleLiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDoubleLiteralStmt(s)
	}
}

func (p *JetRuleParser) DoubleLiteralStmt() (localctx IDoubleLiteralStmtContext) {
	localctx = NewDoubleLiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, JetRuleParserRULE_doubleLiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(443)

		var _m = p.Match(JetRuleParserDoubleType)

		localctx.(*DoubleLiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(444)

		var _x = p.DeclIdentifier()

		localctx.(*DoubleLiteralStmtContext).varName = _x
	}
	{
		p.SetState(445)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(446)

		var _x = p.DoubleExpr()

		localctx.(*DoubleLiteralStmtContext).declValue = _x
	}
	{
		p.SetState(447)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralStmtContext is an interface to support dynamic dispatch.
type IStringLiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// GetDeclValue returns the declValue token.
	GetDeclValue() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// SetDeclValue sets the declValue token.
	SetDeclValue(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	StringType() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	STRING() antlr.TerminalNode

	// IsStringLiteralStmtContext differentiates from other interfaces.
	IsStringLiteralStmtContext()
}

type StringLiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue antlr.Token
}

func NewEmptyStringLiteralStmtContext() *StringLiteralStmtContext {
	var p = new(StringLiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_stringLiteralStmt
	return p
}

func InitEmptyStringLiteralStmtContext(p *StringLiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_stringLiteralStmt
}

func (*StringLiteralStmtContext) IsStringLiteralStmtContext() {}

func NewStringLiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralStmtContext {
	var p = new(StringLiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_stringLiteralStmt

	return p
}

func (s *StringLiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *StringLiteralStmtContext) GetDeclValue() antlr.Token { return s.declValue }

func (s *StringLiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *StringLiteralStmtContext) SetDeclValue(v antlr.Token) { s.declValue = v }

func (s *StringLiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *StringLiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *StringLiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *StringLiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *StringLiteralStmtContext) StringType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserStringType, 0)
}

func (s *StringLiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *StringLiteralStmtContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *StringLiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterStringLiteralStmt(s)
	}
}

func (s *StringLiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitStringLiteralStmt(s)
	}
}

func (p *JetRuleParser) StringLiteralStmt() (localctx IStringLiteralStmtContext) {
	localctx = NewStringLiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, JetRuleParserRULE_stringLiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)

		var _m = p.Match(JetRuleParserStringType)

		localctx.(*StringLiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(450)

		var _x = p.DeclIdentifier()

		localctx.(*StringLiteralStmtContext).varName = _x
	}
	{
		p.SetState(451)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(452)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*StringLiteralStmtContext).declValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(453)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateLiteralStmtContext is an interface to support dynamic dispatch.
type IDateLiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// GetDeclValue returns the declValue token.
	GetDeclValue() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// SetDeclValue sets the declValue token.
	SetDeclValue(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	DateType() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	STRING() antlr.TerminalNode

	// IsDateLiteralStmtContext differentiates from other interfaces.
	IsDateLiteralStmtContext()
}

type DateLiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue antlr.Token
}

func NewEmptyDateLiteralStmtContext() *DateLiteralStmtContext {
	var p = new(DateLiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_dateLiteralStmt
	return p
}

func InitEmptyDateLiteralStmtContext(p *DateLiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_dateLiteralStmt
}

func (*DateLiteralStmtContext) IsDateLiteralStmtContext() {}

func NewDateLiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateLiteralStmtContext {
	var p = new(DateLiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_dateLiteralStmt

	return p
}

func (s *DateLiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DateLiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *DateLiteralStmtContext) GetDeclValue() antlr.Token { return s.declValue }

func (s *DateLiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *DateLiteralStmtContext) SetDeclValue(v antlr.Token) { s.declValue = v }

func (s *DateLiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *DateLiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *DateLiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *DateLiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *DateLiteralStmtContext) DateType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDateType, 0)
}

func (s *DateLiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *DateLiteralStmtContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *DateLiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateLiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDateLiteralStmt(s)
	}
}

func (s *DateLiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDateLiteralStmt(s)
	}
}

func (p *JetRuleParser) DateLiteralStmt() (localctx IDateLiteralStmtContext) {
	localctx = NewDateLiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, JetRuleParserRULE_dateLiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)

		var _m = p.Match(JetRuleParserDateType)

		localctx.(*DateLiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(456)

		var _x = p.DeclIdentifier()

		localctx.(*DateLiteralStmtContext).varName = _x
	}
	{
		p.SetState(457)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*DateLiteralStmtContext).declValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(459)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeLiteralStmtContext is an interface to support dynamic dispatch.
type IDatetimeLiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// GetDeclValue returns the declValue token.
	GetDeclValue() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// SetDeclValue sets the declValue token.
	SetDeclValue(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	DatetimeType() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	STRING() antlr.TerminalNode

	// IsDatetimeLiteralStmtContext differentiates from other interfaces.
	IsDatetimeLiteralStmtContext()
}

type DatetimeLiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue antlr.Token
}

func NewEmptyDatetimeLiteralStmtContext() *DatetimeLiteralStmtContext {
	var p = new(DatetimeLiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_datetimeLiteralStmt
	return p
}

func InitEmptyDatetimeLiteralStmtContext(p *DatetimeLiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_datetimeLiteralStmt
}

func (*DatetimeLiteralStmtContext) IsDatetimeLiteralStmtContext() {}

func NewDatetimeLiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeLiteralStmtContext {
	var p = new(DatetimeLiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_datetimeLiteralStmt

	return p
}

func (s *DatetimeLiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeLiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *DatetimeLiteralStmtContext) GetDeclValue() antlr.Token { return s.declValue }

func (s *DatetimeLiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *DatetimeLiteralStmtContext) SetDeclValue(v antlr.Token) { s.declValue = v }

func (s *DatetimeLiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *DatetimeLiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *DatetimeLiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *DatetimeLiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *DatetimeLiteralStmtContext) DatetimeType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDatetimeType, 0)
}

func (s *DatetimeLiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *DatetimeLiteralStmtContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *DatetimeLiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeLiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeLiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDatetimeLiteralStmt(s)
	}
}

func (s *DatetimeLiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDatetimeLiteralStmt(s)
	}
}

func (p *JetRuleParser) DatetimeLiteralStmt() (localctx IDatetimeLiteralStmtContext) {
	localctx = NewDatetimeLiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, JetRuleParserRULE_datetimeLiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)

		var _m = p.Match(JetRuleParserDatetimeType)

		localctx.(*DatetimeLiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(462)

		var _x = p.DeclIdentifier()

		localctx.(*DatetimeLiteralStmtContext).varName = _x
	}
	{
		p.SetState(463)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(464)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*DatetimeLiteralStmtContext).declValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(465)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralStmtContext is an interface to support dynamic dispatch.
type IBooleanLiteralStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarType returns the varType token.
	GetVarType() antlr.Token

	// GetDeclValue returns the declValue token.
	GetDeclValue() antlr.Token

	// SetVarType sets the varType token.
	SetVarType(antlr.Token)

	// SetDeclValue sets the declValue token.
	SetDeclValue(antlr.Token)

	// GetVarName returns the varName rule contexts.
	GetVarName() IDeclIdentifierContext

	// SetVarName sets the varName rule contexts.
	SetVarName(IDeclIdentifierContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	BoolType() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	STRING() antlr.TerminalNode

	// IsBooleanLiteralStmtContext differentiates from other interfaces.
	IsBooleanLiteralStmtContext()
}

type BooleanLiteralStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	varType   antlr.Token
	varName   IDeclIdentifierContext
	declValue antlr.Token
}

func NewEmptyBooleanLiteralStmtContext() *BooleanLiteralStmtContext {
	var p = new(BooleanLiteralStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_booleanLiteralStmt
	return p
}

func InitEmptyBooleanLiteralStmtContext(p *BooleanLiteralStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_booleanLiteralStmt
}

func (*BooleanLiteralStmtContext) IsBooleanLiteralStmtContext() {}

func NewBooleanLiteralStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralStmtContext {
	var p = new(BooleanLiteralStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_booleanLiteralStmt

	return p
}

func (s *BooleanLiteralStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralStmtContext) GetVarType() antlr.Token { return s.varType }

func (s *BooleanLiteralStmtContext) GetDeclValue() antlr.Token { return s.declValue }

func (s *BooleanLiteralStmtContext) SetVarType(v antlr.Token) { s.varType = v }

func (s *BooleanLiteralStmtContext) SetDeclValue(v antlr.Token) { s.declValue = v }

func (s *BooleanLiteralStmtContext) GetVarName() IDeclIdentifierContext { return s.varName }

func (s *BooleanLiteralStmtContext) SetVarName(v IDeclIdentifierContext) { s.varName = v }

func (s *BooleanLiteralStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *BooleanLiteralStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *BooleanLiteralStmtContext) BoolType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserBoolType, 0)
}

func (s *BooleanLiteralStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *BooleanLiteralStmtContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *BooleanLiteralStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterBooleanLiteralStmt(s)
	}
}

func (s *BooleanLiteralStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitBooleanLiteralStmt(s)
	}
}

func (p *JetRuleParser) BooleanLiteralStmt() (localctx IBooleanLiteralStmtContext) {
	localctx = NewBooleanLiteralStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, JetRuleParserRULE_booleanLiteralStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)

		var _m = p.Match(JetRuleParserBoolType)

		localctx.(*BooleanLiteralStmtContext).varType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(468)

		var _x = p.DeclIdentifier()

		localctx.(*BooleanLiteralStmtContext).varName = _x
	}
	{
		p.SetState(469)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(470)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*BooleanLiteralStmtContext).declValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(471)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntExprContext is an interface to support dynamic dispatch.
type IIntExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	IntExpr() IIntExprContext
	MINUS() antlr.TerminalNode
	DIGITS() antlr.TerminalNode

	// IsIntExprContext differentiates from other interfaces.
	IsIntExprContext()
}

type IntExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntExprContext() *IntExprContext {
	var p = new(IntExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_intExpr
	return p
}

func InitEmptyIntExprContext(p *IntExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_intExpr
}

func (*IntExprContext) IsIntExprContext() {}

func NewIntExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntExprContext {
	var p = new(IntExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_intExpr

	return p
}

func (s *IntExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserPLUS, 0)
}

func (s *IntExprContext) IntExpr() IIntExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntExprContext)
}

func (s *IntExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMINUS, 0)
}

func (s *IntExprContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDIGITS, 0)
}

func (s *IntExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterIntExpr(s)
	}
}

func (s *IntExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitIntExpr(s)
	}
}

func (p *JetRuleParser) IntExpr() (localctx IIntExprContext) {
	localctx = NewIntExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, JetRuleParserRULE_intExpr)
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Match(JetRuleParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(474)
			p.IntExpr()
		}

	case JetRuleParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(475)
			p.Match(JetRuleParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(476)
			p.IntExpr()
		}

	case JetRuleParserDIGITS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(477)
			p.Match(JetRuleParserDIGITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUintExprContext is an interface to support dynamic dispatch.
type IUintExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	UintExpr() IUintExprContext
	DIGITS() antlr.TerminalNode

	// IsUintExprContext differentiates from other interfaces.
	IsUintExprContext()
}

type UintExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUintExprContext() *UintExprContext {
	var p = new(UintExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_uintExpr
	return p
}

func InitEmptyUintExprContext(p *UintExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_uintExpr
}

func (*UintExprContext) IsUintExprContext() {}

func NewUintExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UintExprContext {
	var p = new(UintExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_uintExpr

	return p
}

func (s *UintExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UintExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserPLUS, 0)
}

func (s *UintExprContext) UintExpr() IUintExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUintExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUintExprContext)
}

func (s *UintExprContext) DIGITS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDIGITS, 0)
}

func (s *UintExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UintExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UintExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUintExpr(s)
	}
}

func (s *UintExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUintExpr(s)
	}
}

func (p *JetRuleParser) UintExpr() (localctx IUintExprContext) {
	localctx = NewUintExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, JetRuleParserRULE_uintExpr)
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(480)
			p.Match(JetRuleParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(481)
			p.UintExpr()
		}

	case JetRuleParserDIGITS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(482)
			p.Match(JetRuleParserDIGITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleExprContext is an interface to support dynamic dispatch.
type IDoubleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	DoubleExpr() IDoubleExprContext
	MINUS() antlr.TerminalNode
	AllDIGITS() []antlr.TerminalNode
	DIGITS(i int) antlr.TerminalNode

	// IsDoubleExprContext differentiates from other interfaces.
	IsDoubleExprContext()
}

type DoubleExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleExprContext() *DoubleExprContext {
	var p = new(DoubleExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_doubleExpr
	return p
}

func InitEmptyDoubleExprContext(p *DoubleExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_doubleExpr
}

func (*DoubleExprContext) IsDoubleExprContext() {}

func NewDoubleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleExprContext {
	var p = new(DoubleExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_doubleExpr

	return p
}

func (s *DoubleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserPLUS, 0)
}

func (s *DoubleExprContext) DoubleExpr() IDoubleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleExprContext)
}

func (s *DoubleExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMINUS, 0)
}

func (s *DoubleExprContext) AllDIGITS() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserDIGITS)
}

func (s *DoubleExprContext) DIGITS(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserDIGITS, i)
}

func (s *DoubleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDoubleExpr(s)
	}
}

func (s *DoubleExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDoubleExpr(s)
	}
}

func (p *JetRuleParser) DoubleExpr() (localctx IDoubleExprContext) {
	localctx = NewDoubleExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, JetRuleParserRULE_doubleExpr)
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(485)
			p.Match(JetRuleParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.DoubleExpr()
		}

	case JetRuleParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(487)
			p.Match(JetRuleParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(488)
			p.DoubleExpr()
		}

	case JetRuleParserDIGITS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(489)
			p.Match(JetRuleParserDIGITS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(490)
				p.Match(JetRuleParserT__6)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(491)
				p.Match(JetRuleParserDIGITS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclIdentifierContext is an interface to support dynamic dispatch.
type IDeclIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []antlr.TerminalNode
	Identifier(i int) antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsDeclIdentifierContext differentiates from other interfaces.
	IsDeclIdentifierContext()
}

type DeclIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclIdentifierContext() *DeclIdentifierContext {
	var p = new(DeclIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_declIdentifier
	return p
}

func InitEmptyDeclIdentifierContext(p *DeclIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_declIdentifier
}

func (*DeclIdentifierContext) IsDeclIdentifierContext() {}

func NewDeclIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclIdentifierContext {
	var p = new(DeclIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_declIdentifier

	return p
}

func (s *DeclIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclIdentifierContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserIdentifier)
}

func (s *DeclIdentifierContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, i)
}

func (s *DeclIdentifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *DeclIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDeclIdentifier(s)
	}
}

func (s *DeclIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDeclIdentifier(s)
	}
}

func (p *JetRuleParser) DeclIdentifier() (localctx IDeclIdentifierContext) {
	localctx = NewDeclIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, JetRuleParserRULE_declIdentifier)
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(496)
			p.Match(JetRuleParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.Match(JetRuleParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(498)
			p.Match(JetRuleParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(499)
			p.Match(JetRuleParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(500)
			p.Match(JetRuleParserT__7)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(JetRuleParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(502)
			p.Match(JetRuleParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefineResourceStmtContext is an interface to support dynamic dispatch.
type IDefineResourceStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedResourceStmt() INamedResourceStmtContext
	VolatileResourceStmt() IVolatileResourceStmtContext

	// IsDefineResourceStmtContext differentiates from other interfaces.
	IsDefineResourceStmtContext()
}

type DefineResourceStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefineResourceStmtContext() *DefineResourceStmtContext {
	var p = new(DefineResourceStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineResourceStmt
	return p
}

func InitEmptyDefineResourceStmtContext(p *DefineResourceStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_defineResourceStmt
}

func (*DefineResourceStmtContext) IsDefineResourceStmtContext() {}

func NewDefineResourceStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefineResourceStmtContext {
	var p = new(DefineResourceStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_defineResourceStmt

	return p
}

func (s *DefineResourceStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DefineResourceStmtContext) NamedResourceStmt() INamedResourceStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedResourceStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedResourceStmtContext)
}

func (s *DefineResourceStmtContext) VolatileResourceStmt() IVolatileResourceStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVolatileResourceStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVolatileResourceStmtContext)
}

func (s *DefineResourceStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineResourceStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefineResourceStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterDefineResourceStmt(s)
	}
}

func (s *DefineResourceStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitDefineResourceStmt(s)
	}
}

func (p *JetRuleParser) DefineResourceStmt() (localctx IDefineResourceStmtContext) {
	localctx = NewDefineResourceStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, JetRuleParserRULE_defineResourceStmt)
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserResourceType:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.NamedResourceStmt()
		}

	case JetRuleParserVolatileResourceType:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(506)
			p.VolatileResourceStmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedResourceStmtContext is an interface to support dynamic dispatch.
type INamedResourceStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResName returns the resName rule contexts.
	GetResName() IDeclIdentifierContext

	// GetResCtx returns the resCtx rule contexts.
	GetResCtx() IResourceValueContext

	// SetResName sets the resName rule contexts.
	SetResName(IDeclIdentifierContext)

	// SetResCtx sets the resCtx rule contexts.
	SetResCtx(IResourceValueContext)

	// Getter signatures
	ResourceType() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	ResourceValue() IResourceValueContext

	// IsNamedResourceStmtContext differentiates from other interfaces.
	IsNamedResourceStmtContext()
}

type NamedResourceStmtContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	resName IDeclIdentifierContext
	resCtx  IResourceValueContext
}

func NewEmptyNamedResourceStmtContext() *NamedResourceStmtContext {
	var p = new(NamedResourceStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_namedResourceStmt
	return p
}

func InitEmptyNamedResourceStmtContext(p *NamedResourceStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_namedResourceStmt
}

func (*NamedResourceStmtContext) IsNamedResourceStmtContext() {}

func NewNamedResourceStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedResourceStmtContext {
	var p = new(NamedResourceStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_namedResourceStmt

	return p
}

func (s *NamedResourceStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedResourceStmtContext) GetResName() IDeclIdentifierContext { return s.resName }

func (s *NamedResourceStmtContext) GetResCtx() IResourceValueContext { return s.resCtx }

func (s *NamedResourceStmtContext) SetResName(v IDeclIdentifierContext) { s.resName = v }

func (s *NamedResourceStmtContext) SetResCtx(v IResourceValueContext) { s.resCtx = v }

func (s *NamedResourceStmtContext) ResourceType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserResourceType, 0)
}

func (s *NamedResourceStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *NamedResourceStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *NamedResourceStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *NamedResourceStmtContext) ResourceValue() IResourceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceValueContext)
}

func (s *NamedResourceStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedResourceStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedResourceStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterNamedResourceStmt(s)
	}
}

func (s *NamedResourceStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitNamedResourceStmt(s)
	}
}

func (p *JetRuleParser) NamedResourceStmt() (localctx INamedResourceStmtContext) {
	localctx = NewNamedResourceStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, JetRuleParserRULE_namedResourceStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Match(JetRuleParserResourceType)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(510)

		var _x = p.DeclIdentifier()

		localctx.(*NamedResourceStmtContext).resName = _x
	}
	{
		p.SetState(511)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(512)

		var _x = p.ResourceValue()

		localctx.(*NamedResourceStmtContext).resCtx = _x
	}
	{
		p.SetState(513)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVolatileResourceStmtContext is an interface to support dynamic dispatch.
type IVolatileResourceStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResType returns the resType token.
	GetResType() antlr.Token

	// GetResVal returns the resVal token.
	GetResVal() antlr.Token

	// SetResType sets the resType token.
	SetResType(antlr.Token)

	// SetResVal sets the resVal token.
	SetResVal(antlr.Token)

	// GetResName returns the resName rule contexts.
	GetResName() IDeclIdentifierContext

	// SetResName sets the resName rule contexts.
	SetResName(IDeclIdentifierContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	VolatileResourceType() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	STRING() antlr.TerminalNode

	// IsVolatileResourceStmtContext differentiates from other interfaces.
	IsVolatileResourceStmtContext()
}

type VolatileResourceStmtContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	resType antlr.Token
	resName IDeclIdentifierContext
	resVal  antlr.Token
}

func NewEmptyVolatileResourceStmtContext() *VolatileResourceStmtContext {
	var p = new(VolatileResourceStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_volatileResourceStmt
	return p
}

func InitEmptyVolatileResourceStmtContext(p *VolatileResourceStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_volatileResourceStmt
}

func (*VolatileResourceStmtContext) IsVolatileResourceStmtContext() {}

func NewVolatileResourceStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VolatileResourceStmtContext {
	var p = new(VolatileResourceStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_volatileResourceStmt

	return p
}

func (s *VolatileResourceStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *VolatileResourceStmtContext) GetResType() antlr.Token { return s.resType }

func (s *VolatileResourceStmtContext) GetResVal() antlr.Token { return s.resVal }

func (s *VolatileResourceStmtContext) SetResType(v antlr.Token) { s.resType = v }

func (s *VolatileResourceStmtContext) SetResVal(v antlr.Token) { s.resVal = v }

func (s *VolatileResourceStmtContext) GetResName() IDeclIdentifierContext { return s.resName }

func (s *VolatileResourceStmtContext) SetResName(v IDeclIdentifierContext) { s.resName = v }

func (s *VolatileResourceStmtContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *VolatileResourceStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *VolatileResourceStmtContext) VolatileResourceType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserVolatileResourceType, 0)
}

func (s *VolatileResourceStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *VolatileResourceStmtContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *VolatileResourceStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VolatileResourceStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VolatileResourceStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterVolatileResourceStmt(s)
	}
}

func (s *VolatileResourceStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitVolatileResourceStmt(s)
	}
}

func (p *JetRuleParser) VolatileResourceStmt() (localctx IVolatileResourceStmtContext) {
	localctx = NewVolatileResourceStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, JetRuleParserRULE_volatileResourceStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)

		var _m = p.Match(JetRuleParserVolatileResourceType)

		localctx.(*VolatileResourceStmtContext).resType = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(516)

		var _x = p.DeclIdentifier()

		localctx.(*VolatileResourceStmtContext).resName = _x
	}
	{
		p.SetState(517)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(518)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*VolatileResourceStmtContext).resVal = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(519)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceValueContext is an interface to support dynamic dispatch.
type IResourceValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResVal returns the resVal token.
	GetResVal() antlr.Token

	// SetResVal sets the resVal token.
	SetResVal(antlr.Token)

	// GetKws returns the kws rule contexts.
	GetKws() IKeywordsContext

	// SetKws sets the kws rule contexts.
	SetKws(IKeywordsContext)

	// Getter signatures
	Keywords() IKeywordsContext
	CreateUUIDResource() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsResourceValueContext differentiates from other interfaces.
	IsResourceValueContext()
}

type ResourceValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	kws    IKeywordsContext
	resVal antlr.Token
}

func NewEmptyResourceValueContext() *ResourceValueContext {
	var p = new(ResourceValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_resourceValue
	return p
}

func InitEmptyResourceValueContext(p *ResourceValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_resourceValue
}

func (*ResourceValueContext) IsResourceValueContext() {}

func NewResourceValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceValueContext {
	var p = new(ResourceValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_resourceValue

	return p
}

func (s *ResourceValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceValueContext) GetResVal() antlr.Token { return s.resVal }

func (s *ResourceValueContext) SetResVal(v antlr.Token) { s.resVal = v }

func (s *ResourceValueContext) GetKws() IKeywordsContext { return s.kws }

func (s *ResourceValueContext) SetKws(v IKeywordsContext) { s.kws = v }

func (s *ResourceValueContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *ResourceValueContext) CreateUUIDResource() antlr.TerminalNode {
	return s.GetToken(JetRuleParserCreateUUIDResource, 0)
}

func (s *ResourceValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *ResourceValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterResourceValue(s)
	}
}

func (s *ResourceValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitResourceValue(s)
	}
}

func (p *JetRuleParser) ResourceValue() (localctx IResourceValueContext) {
	localctx = NewResourceValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, JetRuleParserRULE_resourceValue)
	p.SetState(524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserTRUE, JetRuleParserFALSE, JetRuleParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(521)

			var _x = p.Keywords()

			localctx.(*ResourceValueContext).kws = _x
		}

	case JetRuleParserCreateUUIDResource:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(522)

			var _m = p.Match(JetRuleParserCreateUUIDResource)

			localctx.(*ResourceValueContext).resVal = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(523)

			var _m = p.Match(JetRuleParserSTRING)

			localctx.(*ResourceValueContext).resVal = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookupTableStmtContext is an interface to support dynamic dispatch.
type ILookupTableStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLookupName returns the lookupName rule contexts.
	GetLookupName() IDeclIdentifierContext

	// GetTblKeys returns the tblKeys rule contexts.
	GetTblKeys() IStringListContext

	// SetLookupName sets the lookupName rule contexts.
	SetLookupName(IDeclIdentifierContext)

	// SetTblKeys sets the tblKeys rule contexts.
	SetTblKeys(IStringListContext)

	// Getter signatures
	LookupTable() antlr.TerminalNode
	CsvLocation() ICsvLocationContext
	Key() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	Columns() antlr.TerminalNode
	ColumnDefSeq() IColumnDefSeqContext
	SEMICOLON() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	StringList() IStringListContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsLookupTableStmtContext differentiates from other interfaces.
	IsLookupTableStmtContext()
}

type LookupTableStmtContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	lookupName IDeclIdentifierContext
	tblKeys    IStringListContext
}

func NewEmptyLookupTableStmtContext() *LookupTableStmtContext {
	var p = new(LookupTableStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_lookupTableStmt
	return p
}

func InitEmptyLookupTableStmtContext(p *LookupTableStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_lookupTableStmt
}

func (*LookupTableStmtContext) IsLookupTableStmtContext() {}

func NewLookupTableStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupTableStmtContext {
	var p = new(LookupTableStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_lookupTableStmt

	return p
}

func (s *LookupTableStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupTableStmtContext) GetLookupName() IDeclIdentifierContext { return s.lookupName }

func (s *LookupTableStmtContext) GetTblKeys() IStringListContext { return s.tblKeys }

func (s *LookupTableStmtContext) SetLookupName(v IDeclIdentifierContext) { s.lookupName = v }

func (s *LookupTableStmtContext) SetTblKeys(v IStringListContext) { s.tblKeys = v }

func (s *LookupTableStmtContext) LookupTable() antlr.TerminalNode {
	return s.GetToken(JetRuleParserLookupTable, 0)
}

func (s *LookupTableStmtContext) CsvLocation() ICsvLocationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICsvLocationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICsvLocationContext)
}

func (s *LookupTableStmtContext) Key() antlr.TerminalNode {
	return s.GetToken(JetRuleParserKey, 0)
}

func (s *LookupTableStmtContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserASSIGN)
}

func (s *LookupTableStmtContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, i)
}

func (s *LookupTableStmtContext) Columns() antlr.TerminalNode {
	return s.GetToken(JetRuleParserColumns, 0)
}

func (s *LookupTableStmtContext) ColumnDefSeq() IColumnDefSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefSeqContext)
}

func (s *LookupTableStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *LookupTableStmtContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *LookupTableStmtContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *LookupTableStmtContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *LookupTableStmtContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *LookupTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupTableStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterLookupTableStmt(s)
	}
}

func (s *LookupTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitLookupTableStmt(s)
	}
}

func (p *JetRuleParser) LookupTableStmt() (localctx ILookupTableStmtContext) {
	localctx = NewLookupTableStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, JetRuleParserRULE_lookupTableStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.Match(JetRuleParserLookupTable)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(527)

		var _x = p.DeclIdentifier()

		localctx.(*LookupTableStmtContext).lookupName = _x
	}
	{
		p.SetState(528)
		p.Match(JetRuleParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(529)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(535)
		p.CsvLocation()
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(536)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(542)
		p.Match(JetRuleParserKey)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(543)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(544)

		var _x = p.StringList()

		localctx.(*LookupTableStmtContext).tblKeys = _x
	}
	{
		p.SetState(545)
		p.Match(JetRuleParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(546)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(552)
		p.Match(JetRuleParserColumns)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(553)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(554)
		p.Match(JetRuleParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(555)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(561)
		p.ColumnDefSeq()
	}
	p.SetState(565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(562)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(568)
		p.Match(JetRuleParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserT__2 {
		{
			p.SetState(569)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(572)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(578)
		p.Match(JetRuleParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(579)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICsvLocationContext is an interface to support dynamic dispatch.
type ICsvLocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCsvFileName returns the csvFileName token.
	GetCsvFileName() antlr.Token

	// SetCsvFileName sets the csvFileName token.
	SetCsvFileName(antlr.Token)

	// GetTblStorageName returns the tblStorageName rule contexts.
	GetTblStorageName() IDeclIdentifierContext

	// SetTblStorageName sets the tblStorageName rule contexts.
	SetTblStorageName(IDeclIdentifierContext)

	// Getter signatures
	TableName() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext
	CSVFileName() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsCsvLocationContext differentiates from other interfaces.
	IsCsvLocationContext()
}

type CsvLocationContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	tblStorageName IDeclIdentifierContext
	csvFileName    antlr.Token
}

func NewEmptyCsvLocationContext() *CsvLocationContext {
	var p = new(CsvLocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_csvLocation
	return p
}

func InitEmptyCsvLocationContext(p *CsvLocationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_csvLocation
}

func (*CsvLocationContext) IsCsvLocationContext() {}

func NewCsvLocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CsvLocationContext {
	var p = new(CsvLocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_csvLocation

	return p
}

func (s *CsvLocationContext) GetParser() antlr.Parser { return s.parser }

func (s *CsvLocationContext) GetCsvFileName() antlr.Token { return s.csvFileName }

func (s *CsvLocationContext) SetCsvFileName(v antlr.Token) { s.csvFileName = v }

func (s *CsvLocationContext) GetTblStorageName() IDeclIdentifierContext { return s.tblStorageName }

func (s *CsvLocationContext) SetTblStorageName(v IDeclIdentifierContext) { s.tblStorageName = v }

func (s *CsvLocationContext) TableName() antlr.TerminalNode {
	return s.GetToken(JetRuleParserTableName, 0)
}

func (s *CsvLocationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *CsvLocationContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *CsvLocationContext) CSVFileName() antlr.TerminalNode {
	return s.GetToken(JetRuleParserCSVFileName, 0)
}

func (s *CsvLocationContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *CsvLocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CsvLocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CsvLocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterCsvLocation(s)
	}
}

func (s *CsvLocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitCsvLocation(s)
	}
}

func (p *JetRuleParser) CsvLocation() (localctx ICsvLocationContext) {
	localctx = NewCsvLocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, JetRuleParserRULE_csvLocation)
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserTableName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(581)
			p.Match(JetRuleParserTableName)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(583)

			var _x = p.DeclIdentifier()

			localctx.(*CsvLocationContext).tblStorageName = _x
		}
		{
			p.SetState(584)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserCSVFileName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(586)
			p.Match(JetRuleParserCSVFileName)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(587)
			p.Match(JetRuleParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)

			var _m = p.Match(JetRuleParserSTRING)

			localctx.(*CsvLocationContext).csvFileName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(589)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeqCtx returns the seqCtx rule contexts.
	GetSeqCtx() IStringSeqContext

	// SetSeqCtx sets the seqCtx rule contexts.
	SetSeqCtx(IStringSeqContext)

	// Getter signatures
	StringSeq() IStringSeqContext

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seqCtx IStringSeqContext
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) GetSeqCtx() IStringSeqContext { return s.seqCtx }

func (s *StringListContext) SetSeqCtx(v IStringSeqContext) { s.seqCtx = v }

func (s *StringListContext) StringSeq() IStringSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringSeqContext)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (p *JetRuleParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, JetRuleParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)
		p.Match(JetRuleParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserSTRING {
		{
			p.SetState(593)

			var _x = p.StringSeq()

			localctx.(*StringListContext).seqCtx = _x
		}

	}
	{
		p.SetState(596)
		p.Match(JetRuleParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringSeqContext is an interface to support dynamic dispatch.
type IStringSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRING returns the _STRING token.
	Get_STRING() antlr.Token

	// Set_STRING sets the _STRING token.
	Set_STRING(antlr.Token)

	// GetSlist returns the slist token list.
	GetSlist() []antlr.Token

	// SetSlist sets the slist token list.
	SetSlist([]antlr.Token)

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsStringSeqContext differentiates from other interfaces.
	IsStringSeqContext()
}

type StringSeqContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	_STRING antlr.Token
	slist   []antlr.Token
}

func NewEmptyStringSeqContext() *StringSeqContext {
	var p = new(StringSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_stringSeq
	return p
}

func InitEmptyStringSeqContext(p *StringSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_stringSeq
}

func (*StringSeqContext) IsStringSeqContext() {}

func NewStringSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSeqContext {
	var p = new(StringSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_stringSeq

	return p
}

func (s *StringSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSeqContext) Get_STRING() antlr.Token { return s._STRING }

func (s *StringSeqContext) Set_STRING(v antlr.Token) { s._STRING = v }

func (s *StringSeqContext) GetSlist() []antlr.Token { return s.slist }

func (s *StringSeqContext) SetSlist(v []antlr.Token) { s.slist = v }

func (s *StringSeqContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserSTRING)
}

func (s *StringSeqContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, i)
}

func (s *StringSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterStringSeq(s)
	}
}

func (s *StringSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitStringSeq(s)
	}
}

func (p *JetRuleParser) StringSeq() (localctx IStringSeqContext) {
	localctx = NewStringSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, JetRuleParserRULE_stringSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*StringSeqContext)._STRING = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*StringSeqContext).slist = append(localctx.(*StringSeqContext).slist, localctx.(*StringSeqContext)._STRING)
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserT__2 {
		{
			p.SetState(599)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(600)

			var _m = p.Match(JetRuleParserSTRING)

			localctx.(*StringSeqContext)._STRING = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*StringSeqContext).slist = append(localctx.(*StringSeqContext).slist, localctx.(*StringSeqContext)._STRING)

		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefSeqContext is an interface to support dynamic dispatch.
type IColumnDefSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnDefinitions() []IColumnDefinitionsContext
	ColumnDefinitions(i int) IColumnDefinitionsContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode

	// IsColumnDefSeqContext differentiates from other interfaces.
	IsColumnDefSeqContext()
}

type ColumnDefSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefSeqContext() *ColumnDefSeqContext {
	var p = new(ColumnDefSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_columnDefSeq
	return p
}

func InitEmptyColumnDefSeqContext(p *ColumnDefSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_columnDefSeq
}

func (*ColumnDefSeqContext) IsColumnDefSeqContext() {}

func NewColumnDefSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefSeqContext {
	var p = new(ColumnDefSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_columnDefSeq

	return p
}

func (s *ColumnDefSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefSeqContext) AllColumnDefinitions() []IColumnDefinitionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionsContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionsContext); ok {
			tst[i] = t.(IColumnDefinitionsContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefSeqContext) ColumnDefinitions(i int) IColumnDefinitionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionsContext)
}

func (s *ColumnDefSeqContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *ColumnDefSeqContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *ColumnDefSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterColumnDefSeq(s)
	}
}

func (s *ColumnDefSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitColumnDefSeq(s)
	}
}

func (p *JetRuleParser) ColumnDefSeq() (localctx IColumnDefSeqContext) {
	localctx = NewColumnDefSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, JetRuleParserRULE_columnDefSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.ColumnDefinitions()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserT__2 {
		{
			p.SetState(607)
			p.Match(JetRuleParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(608)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(613)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(614)
			p.ColumnDefinitions()
		}

		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionsContext is an interface to support dynamic dispatch.
type IColumnDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName token.
	GetColumnName() antlr.Token

	// GetArray returns the array token.
	GetArray() antlr.Token

	// SetColumnName sets the columnName token.
	SetColumnName(antlr.Token)

	// SetArray sets the array token.
	SetArray(antlr.Token)

	// GetColumnType returns the columnType rule contexts.
	GetColumnType() IDataPropertyTypeContext

	// SetColumnType sets the columnType rule contexts.
	SetColumnType(IDataPropertyTypeContext)

	// Getter signatures
	STRING() antlr.TerminalNode
	DataPropertyType() IDataPropertyTypeContext
	ARRAY() antlr.TerminalNode

	// IsColumnDefinitionsContext differentiates from other interfaces.
	IsColumnDefinitionsContext()
}

type ColumnDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	columnName antlr.Token
	array      antlr.Token
	columnType IDataPropertyTypeContext
}

func NewEmptyColumnDefinitionsContext() *ColumnDefinitionsContext {
	var p = new(ColumnDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_columnDefinitions
	return p
}

func InitEmptyColumnDefinitionsContext(p *ColumnDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_columnDefinitions
}

func (*ColumnDefinitionsContext) IsColumnDefinitionsContext() {}

func NewColumnDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionsContext {
	var p = new(ColumnDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_columnDefinitions

	return p
}

func (s *ColumnDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionsContext) GetColumnName() antlr.Token { return s.columnName }

func (s *ColumnDefinitionsContext) GetArray() antlr.Token { return s.array }

func (s *ColumnDefinitionsContext) SetColumnName(v antlr.Token) { s.columnName = v }

func (s *ColumnDefinitionsContext) SetArray(v antlr.Token) { s.array = v }

func (s *ColumnDefinitionsContext) GetColumnType() IDataPropertyTypeContext { return s.columnType }

func (s *ColumnDefinitionsContext) SetColumnType(v IDataPropertyTypeContext) { s.columnType = v }

func (s *ColumnDefinitionsContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *ColumnDefinitionsContext) DataPropertyType() IDataPropertyTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataPropertyTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataPropertyTypeContext)
}

func (s *ColumnDefinitionsContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(JetRuleParserARRAY, 0)
}

func (s *ColumnDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterColumnDefinitions(s)
	}
}

func (s *ColumnDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitColumnDefinitions(s)
	}
}

func (p *JetRuleParser) ColumnDefinitions() (localctx IColumnDefinitionsContext) {
	localctx = NewColumnDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, JetRuleParserRULE_columnDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(620)

		var _m = p.Match(JetRuleParserSTRING)

		localctx.(*ColumnDefinitionsContext).columnName = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(621)
		p.Match(JetRuleParserT__5)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserARRAY {
		{
			p.SetState(622)

			var _m = p.Match(JetRuleParserARRAY)

			localctx.(*ColumnDefinitionsContext).array = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(625)

		var _x = p.DataPropertyType()

		localctx.(*ColumnDefinitionsContext).columnType = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJetRuleStmtContext is an interface to support dynamic dispatch.
type IJetRuleStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRuleName returns the ruleName token.
	GetRuleName() antlr.Token

	// SetRuleName sets the ruleName token.
	SetRuleName(antlr.Token)

	// Getter signatures
	SEMICOLON() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	AllRuleProperties() []IRulePropertiesContext
	RuleProperties(i int) IRulePropertiesContext
	AllCOMMENT() []antlr.TerminalNode
	COMMENT(i int) antlr.TerminalNode
	AllAntecedent() []IAntecedentContext
	Antecedent(i int) IAntecedentContext
	AllConsequent() []IConsequentContext
	Consequent(i int) IConsequentContext

	// IsJetRuleStmtContext differentiates from other interfaces.
	IsJetRuleStmtContext()
}

type JetRuleStmtContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ruleName antlr.Token
}

func NewEmptyJetRuleStmtContext() *JetRuleStmtContext {
	var p = new(JetRuleStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetRuleStmt
	return p
}

func InitEmptyJetRuleStmtContext(p *JetRuleStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_jetRuleStmt
}

func (*JetRuleStmtContext) IsJetRuleStmtContext() {}

func NewJetRuleStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JetRuleStmtContext {
	var p = new(JetRuleStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_jetRuleStmt

	return p
}

func (s *JetRuleStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *JetRuleStmtContext) GetRuleName() antlr.Token { return s.ruleName }

func (s *JetRuleStmtContext) SetRuleName(v antlr.Token) { s.ruleName = v }

func (s *JetRuleStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *JetRuleStmtContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, 0)
}

func (s *JetRuleStmtContext) AllRuleProperties() []IRulePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRulePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IRulePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRulePropertiesContext); ok {
			tst[i] = t.(IRulePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *JetRuleStmtContext) RuleProperties(i int) IRulePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePropertiesContext)
}

func (s *JetRuleStmtContext) AllCOMMENT() []antlr.TerminalNode {
	return s.GetTokens(JetRuleParserCOMMENT)
}

func (s *JetRuleStmtContext) COMMENT(i int) antlr.TerminalNode {
	return s.GetToken(JetRuleParserCOMMENT, i)
}

func (s *JetRuleStmtContext) AllAntecedent() []IAntecedentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAntecedentContext); ok {
			len++
		}
	}

	tst := make([]IAntecedentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAntecedentContext); ok {
			tst[i] = t.(IAntecedentContext)
			i++
		}
	}

	return tst
}

func (s *JetRuleStmtContext) Antecedent(i int) IAntecedentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAntecedentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAntecedentContext)
}

func (s *JetRuleStmtContext) AllConsequent() []IConsequentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConsequentContext); ok {
			len++
		}
	}

	tst := make([]IConsequentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConsequentContext); ok {
			tst[i] = t.(IConsequentContext)
			i++
		}
	}

	return tst
}

func (s *JetRuleStmtContext) Consequent(i int) IConsequentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConsequentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConsequentContext)
}

func (s *JetRuleStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JetRuleStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JetRuleStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterJetRuleStmt(s)
	}
}

func (s *JetRuleStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitJetRuleStmt(s)
	}
}

func (p *JetRuleParser) JetRuleStmt() (localctx IJetRuleStmtContext) {
	localctx = NewJetRuleStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, JetRuleParserRULE_jetRuleStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.Match(JetRuleParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(628)

		var _m = p.Match(JetRuleParserIdentifier)

		localctx.(*JetRuleStmtContext).ruleName = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserT__2 {
		{
			p.SetState(629)
			p.RuleProperties()
		}

		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(635)
		p.Match(JetRuleParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(636)
		p.Match(JetRuleParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(637)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JetRuleParserT__9 || _la == JetRuleParserNOT {
		{
			p.SetState(643)
			p.Antecedent()
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(644)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(649)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(654)
		p.Match(JetRuleParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == JetRuleParserCOMMENT {
		{
			p.SetState(655)
			p.Match(JetRuleParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == JetRuleParserT__9 {
		{
			p.SetState(661)
			p.Consequent()
		}
		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == JetRuleParserCOMMENT {
			{
				p.SetState(662)
				p.Match(JetRuleParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(667)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(672)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRulePropertiesContext is an interface to support dynamic dispatch.
type IRulePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key token.
	GetKey() antlr.Token

	// SetKey sets the key token.
	SetKey(antlr.Token)

	// GetValCtx returns the valCtx rule contexts.
	GetValCtx() IPropertyValueContext

	// SetValCtx sets the valCtx rule contexts.
	SetValCtx(IPropertyValueContext)

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	PropertyValue() IPropertyValueContext

	// IsRulePropertiesContext differentiates from other interfaces.
	IsRulePropertiesContext()
}

type RulePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    antlr.Token
	valCtx IPropertyValueContext
}

func NewEmptyRulePropertiesContext() *RulePropertiesContext {
	var p = new(RulePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_ruleProperties
	return p
}

func InitEmptyRulePropertiesContext(p *RulePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_ruleProperties
}

func (*RulePropertiesContext) IsRulePropertiesContext() {}

func NewRulePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePropertiesContext {
	var p = new(RulePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_ruleProperties

	return p
}

func (s *RulePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePropertiesContext) GetKey() antlr.Token { return s.key }

func (s *RulePropertiesContext) SetKey(v antlr.Token) { s.key = v }

func (s *RulePropertiesContext) GetValCtx() IPropertyValueContext { return s.valCtx }

func (s *RulePropertiesContext) SetValCtx(v IPropertyValueContext) { s.valCtx = v }

func (s *RulePropertiesContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(JetRuleParserASSIGN, 0)
}

func (s *RulePropertiesContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, 0)
}

func (s *RulePropertiesContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *RulePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterRuleProperties(s)
	}
}

func (s *RulePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitRuleProperties(s)
	}
}

func (p *JetRuleParser) RuleProperties() (localctx IRulePropertiesContext) {
	localctx = NewRulePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, JetRuleParserRULE_ruleProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.Match(JetRuleParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(675)

		var _m = p.Match(JetRuleParserIdentifier)

		localctx.(*RulePropertiesContext).key = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(676)
		p.Match(JetRuleParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(677)

		var _x = p.PropertyValue()

		localctx.(*RulePropertiesContext).valCtx = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVal returns the val token.
	GetVal() antlr.Token

	// SetVal sets the val token.
	SetVal(antlr.Token)

	// GetIntval returns the intval rule contexts.
	GetIntval() IIntExprContext

	// SetIntval sets the intval rule contexts.
	SetIntval(IIntExprContext)

	// Getter signatures
	STRING() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	IntExpr() IIntExprContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	val    antlr.Token
	intval IIntExprContext
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) GetVal() antlr.Token { return s.val }

func (s *PropertyValueContext) SetVal(v antlr.Token) { s.val = v }

func (s *PropertyValueContext) GetIntval() IIntExprContext { return s.intval }

func (s *PropertyValueContext) SetIntval(v IIntExprContext) { s.intval = v }

func (s *PropertyValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *PropertyValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserTRUE, 0)
}

func (s *PropertyValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserFALSE, 0)
}

func (s *PropertyValueContext) IntExpr() IIntExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntExprContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterPropertyValue(s)
	}
}

func (s *PropertyValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitPropertyValue(s)
	}
}

func (p *JetRuleParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, JetRuleParserRULE_propertyValue)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserSTRING:
		{
			p.SetState(679)

			var _m = p.Match(JetRuleParserSTRING)

			localctx.(*PropertyValueContext).val = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserTRUE:
		{
			p.SetState(680)

			var _m = p.Match(JetRuleParserTRUE)

			localctx.(*PropertyValueContext).val = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserFALSE:
		{
			p.SetState(681)

			var _m = p.Match(JetRuleParserFALSE)

			localctx.(*PropertyValueContext).val = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserPLUS, JetRuleParserMINUS, JetRuleParserDIGITS:
		{
			p.SetState(682)

			var _x = p.IntExpr()

			localctx.(*PropertyValueContext).intval = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAntecedentContext is an interface to support dynamic dispatch.
type IAntecedentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetN returns the n token.
	GetN() antlr.Token

	// SetN sets the n token.
	SetN(antlr.Token)

	// GetS returns the s rule contexts.
	GetS() IAtomContext

	// GetP returns the p rule contexts.
	GetP() IAtomContext

	// GetO returns the o rule contexts.
	GetO() IObjectAtomContext

	// GetF returns the f rule contexts.
	GetF() IExprTermContext

	// SetS sets the s rule contexts.
	SetS(IAtomContext)

	// SetP sets the p rule contexts.
	SetP(IAtomContext)

	// SetO sets the o rule contexts.
	SetO(IObjectAtomContext)

	// SetF sets the f rule contexts.
	SetF(IExprTermContext)

	// Getter signatures
	AllAtom() []IAtomContext
	Atom(i int) IAtomContext
	ObjectAtom() IObjectAtomContext
	NOT() antlr.TerminalNode
	ExprTerm() IExprTermContext

	// IsAntecedentContext differentiates from other interfaces.
	IsAntecedentContext()
}

type AntecedentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	n      antlr.Token
	s      IAtomContext
	p      IAtomContext
	o      IObjectAtomContext
	f      IExprTermContext
}

func NewEmptyAntecedentContext() *AntecedentContext {
	var p = new(AntecedentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_antecedent
	return p
}

func InitEmptyAntecedentContext(p *AntecedentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_antecedent
}

func (*AntecedentContext) IsAntecedentContext() {}

func NewAntecedentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AntecedentContext {
	var p = new(AntecedentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_antecedent

	return p
}

func (s *AntecedentContext) GetParser() antlr.Parser { return s.parser }

func (s *AntecedentContext) GetN() antlr.Token { return s.n }

func (s *AntecedentContext) SetN(v antlr.Token) { s.n = v }

func (s *AntecedentContext) GetS() IAtomContext { return s.s }

func (s *AntecedentContext) GetP() IAtomContext { return s.p }

func (s *AntecedentContext) GetO() IObjectAtomContext { return s.o }

func (s *AntecedentContext) GetF() IExprTermContext { return s.f }

func (s *AntecedentContext) SetS(v IAtomContext) { s.s = v }

func (s *AntecedentContext) SetP(v IAtomContext) { s.p = v }

func (s *AntecedentContext) SetO(v IObjectAtomContext) { s.o = v }

func (s *AntecedentContext) SetF(v IExprTermContext) { s.f = v }

func (s *AntecedentContext) AllAtom() []IAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtomContext); ok {
			len++
		}
	}

	tst := make([]IAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtomContext); ok {
			tst[i] = t.(IAtomContext)
			i++
		}
	}

	return tst
}

func (s *AntecedentContext) Atom(i int) IAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *AntecedentContext) ObjectAtom() IObjectAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectAtomContext)
}

func (s *AntecedentContext) NOT() antlr.TerminalNode {
	return s.GetToken(JetRuleParserNOT, 0)
}

func (s *AntecedentContext) ExprTerm() IExprTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *AntecedentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AntecedentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AntecedentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterAntecedent(s)
	}
}

func (s *AntecedentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitAntecedent(s)
	}
}

func (p *JetRuleParser) Antecedent() (localctx IAntecedentContext) {
	localctx = NewAntecedentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, JetRuleParserRULE_antecedent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserNOT {
		{
			p.SetState(685)

			var _m = p.Match(JetRuleParserNOT)

			localctx.(*AntecedentContext).n = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(688)
		p.Match(JetRuleParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(689)

		var _x = p.Atom()

		localctx.(*AntecedentContext).s = _x
	}
	{
		p.SetState(690)

		var _x = p.Atom()

		localctx.(*AntecedentContext).p = _x
	}
	{
		p.SetState(691)

		var _x = p.ObjectAtom()

		localctx.(*AntecedentContext).o = _x
	}
	{
		p.SetState(692)
		p.Match(JetRuleParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserT__6 {
		{
			p.SetState(693)
			p.Match(JetRuleParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserT__3 {
		{
			p.SetState(696)
			p.Match(JetRuleParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(697)

			var _x = p.exprTerm(0)

			localctx.(*AntecedentContext).f = _x
		}
		{
			p.SetState(698)
			p.Match(JetRuleParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == JetRuleParserT__6 {
			{
				p.SetState(699)
				p.Match(JetRuleParserT__6)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConsequentContext is an interface to support dynamic dispatch.
type IConsequentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s rule contexts.
	GetS() IAtomContext

	// GetP returns the p rule contexts.
	GetP() IAtomContext

	// GetO returns the o rule contexts.
	GetO() IExprTermContext

	// SetS sets the s rule contexts.
	SetS(IAtomContext)

	// SetP sets the p rule contexts.
	SetP(IAtomContext)

	// SetO sets the o rule contexts.
	SetO(IExprTermContext)

	// Getter signatures
	AllAtom() []IAtomContext
	Atom(i int) IAtomContext
	ExprTerm() IExprTermContext

	// IsConsequentContext differentiates from other interfaces.
	IsConsequentContext()
}

type ConsequentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	s      IAtomContext
	p      IAtomContext
	o      IExprTermContext
}

func NewEmptyConsequentContext() *ConsequentContext {
	var p = new(ConsequentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_consequent
	return p
}

func InitEmptyConsequentContext(p *ConsequentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_consequent
}

func (*ConsequentContext) IsConsequentContext() {}

func NewConsequentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConsequentContext {
	var p = new(ConsequentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_consequent

	return p
}

func (s *ConsequentContext) GetParser() antlr.Parser { return s.parser }

func (s *ConsequentContext) GetS() IAtomContext { return s.s }

func (s *ConsequentContext) GetP() IAtomContext { return s.p }

func (s *ConsequentContext) GetO() IExprTermContext { return s.o }

func (s *ConsequentContext) SetS(v IAtomContext) { s.s = v }

func (s *ConsequentContext) SetP(v IAtomContext) { s.p = v }

func (s *ConsequentContext) SetO(v IExprTermContext) { s.o = v }

func (s *ConsequentContext) AllAtom() []IAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtomContext); ok {
			len++
		}
	}

	tst := make([]IAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtomContext); ok {
			tst[i] = t.(IAtomContext)
			i++
		}
	}

	return tst
}

func (s *ConsequentContext) Atom(i int) IAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ConsequentContext) ExprTerm() IExprTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *ConsequentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConsequentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConsequentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterConsequent(s)
	}
}

func (s *ConsequentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitConsequent(s)
	}
}

func (p *JetRuleParser) Consequent() (localctx IConsequentContext) {
	localctx = NewConsequentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, JetRuleParserRULE_consequent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(JetRuleParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)

		var _x = p.Atom()

		localctx.(*ConsequentContext).s = _x
	}
	{
		p.SetState(706)

		var _x = p.Atom()

		localctx.(*ConsequentContext).p = _x
	}
	{
		p.SetState(707)

		var _x = p.exprTerm(0)

		localctx.(*ConsequentContext).o = _x
	}
	{
		p.SetState(708)
		p.Match(JetRuleParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == JetRuleParserT__6 {
		{
			p.SetState(709)
			p.Match(JetRuleParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	DeclIdentifier() IDeclIdentifierContext

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, 0)
}

func (s *AtomContext) DeclIdentifier() IDeclIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclIdentifierContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *JetRuleParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, JetRuleParserRULE_atom)
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserT__11:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(712)
			p.Match(JetRuleParserT__11)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(713)
			p.Match(JetRuleParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(714)
			p.DeclIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectAtomContext is an interface to support dynamic dispatch.
type IObjectAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKws returns the kws rule contexts.
	GetKws() IKeywordsContext

	// SetKws sets the kws rule contexts.
	SetKws(IKeywordsContext)

	// Getter signatures
	Atom() IAtomContext
	Int32Type() antlr.TerminalNode
	IntExpr() IIntExprContext
	UInt32Type() antlr.TerminalNode
	UintExpr() IUintExprContext
	Int64Type() antlr.TerminalNode
	UInt64Type() antlr.TerminalNode
	DoubleType() antlr.TerminalNode
	DoubleExpr() IDoubleExprContext
	StringType() antlr.TerminalNode
	STRING() antlr.TerminalNode
	DateType() antlr.TerminalNode
	DatetimeType() antlr.TerminalNode
	BoolType() antlr.TerminalNode
	Keywords() IKeywordsContext

	// IsObjectAtomContext differentiates from other interfaces.
	IsObjectAtomContext()
}

type ObjectAtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	kws    IKeywordsContext
}

func NewEmptyObjectAtomContext() *ObjectAtomContext {
	var p = new(ObjectAtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_objectAtom
	return p
}

func InitEmptyObjectAtomContext(p *ObjectAtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_objectAtom
}

func (*ObjectAtomContext) IsObjectAtomContext() {}

func NewObjectAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectAtomContext {
	var p = new(ObjectAtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_objectAtom

	return p
}

func (s *ObjectAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectAtomContext) GetKws() IKeywordsContext { return s.kws }

func (s *ObjectAtomContext) SetKws(v IKeywordsContext) { s.kws = v }

func (s *ObjectAtomContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ObjectAtomContext) Int32Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInt32Type, 0)
}

func (s *ObjectAtomContext) IntExpr() IIntExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntExprContext)
}

func (s *ObjectAtomContext) UInt32Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserUInt32Type, 0)
}

func (s *ObjectAtomContext) UintExpr() IUintExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUintExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUintExprContext)
}

func (s *ObjectAtomContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserInt64Type, 0)
}

func (s *ObjectAtomContext) UInt64Type() antlr.TerminalNode {
	return s.GetToken(JetRuleParserUInt64Type, 0)
}

func (s *ObjectAtomContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDoubleType, 0)
}

func (s *ObjectAtomContext) DoubleExpr() IDoubleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleExprContext)
}

func (s *ObjectAtomContext) StringType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserStringType, 0)
}

func (s *ObjectAtomContext) STRING() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSTRING, 0)
}

func (s *ObjectAtomContext) DateType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDateType, 0)
}

func (s *ObjectAtomContext) DatetimeType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDatetimeType, 0)
}

func (s *ObjectAtomContext) BoolType() antlr.TerminalNode {
	return s.GetToken(JetRuleParserBoolType, 0)
}

func (s *ObjectAtomContext) Keywords() IKeywordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *ObjectAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterObjectAtom(s)
	}
}

func (s *ObjectAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitObjectAtom(s)
	}
}

func (p *JetRuleParser) ObjectAtom() (localctx IObjectAtomContext) {
	localctx = NewObjectAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, JetRuleParserRULE_objectAtom)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case JetRuleParserT__11, JetRuleParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.Atom()
		}

	case JetRuleParserInt32Type:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Match(JetRuleParserInt32Type)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(720)
			p.IntExpr()
		}
		{
			p.SetState(721)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserUInt32Type:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(723)
			p.Match(JetRuleParserUInt32Type)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(724)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(725)
			p.UintExpr()
		}
		{
			p.SetState(726)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserInt64Type:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(728)
			p.Match(JetRuleParserInt64Type)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(729)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)
			p.IntExpr()
		}
		{
			p.SetState(731)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserUInt64Type:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(733)
			p.Match(JetRuleParserUInt64Type)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(734)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)
			p.UintExpr()
		}
		{
			p.SetState(736)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserDoubleType:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(738)
			p.Match(JetRuleParserDoubleType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(739)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.DoubleExpr()
		}
		{
			p.SetState(741)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserStringType:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(743)
			p.Match(JetRuleParserStringType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(744)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)
			p.Match(JetRuleParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserDateType:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(747)
			p.Match(JetRuleParserDateType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(749)
			p.Match(JetRuleParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(750)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserDatetimeType:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(751)
			p.Match(JetRuleParserDatetimeType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(752)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)
			p.Match(JetRuleParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(754)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserBoolType:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(755)
			p.Match(JetRuleParserBoolType)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(756)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(757)
			p.Match(JetRuleParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(758)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserSTRING:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(759)
			p.Match(JetRuleParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case JetRuleParserTRUE, JetRuleParserFALSE, JetRuleParserNULL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(760)

			var _x = p.Keywords()

			localctx.(*ObjectAtomContext).kws = _x
		}

	case JetRuleParserPLUS, JetRuleParserMINUS, JetRuleParserDIGITS:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(761)
			p.DoubleExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordsContext is an interface to support dynamic dispatch.
type IKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsKeywordsContext differentiates from other interfaces.
	IsKeywordsContext()
}

type KeywordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsContext() *KeywordsContext {
	var p = new(KeywordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_keywords
	return p
}

func InitEmptyKeywordsContext(p *KeywordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_keywords
}

func (*KeywordsContext) IsKeywordsContext() {}

func NewKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsContext {
	var p = new(KeywordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_keywords

	return p
}

func (s *KeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsContext) TRUE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserTRUE, 0)
}

func (s *KeywordsContext) FALSE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserFALSE, 0)
}

func (s *KeywordsContext) NULL() antlr.TerminalNode {
	return s.GetToken(JetRuleParserNULL, 0)
}

func (s *KeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterKeywords(s)
	}
}

func (s *KeywordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitKeywords(s)
	}
}

func (p *JetRuleParser) Keywords() (localctx IKeywordsContext) {
	localctx = NewKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, JetRuleParserRULE_keywords)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&246290604621824) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprTermContext is an interface to support dynamic dispatch.
type IExprTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExprTermContext differentiates from other interfaces.
	IsExprTermContext()
}

type ExprTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprTermContext() *ExprTermContext {
	var p = new(ExprTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_exprTerm
	return p
}

func InitEmptyExprTermContext(p *ExprTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_exprTerm
}

func (*ExprTermContext) IsExprTermContext() {}

func NewExprTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprTermContext {
	var p = new(ExprTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_exprTerm

	return p
}

func (s *ExprTermContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprTermContext) CopyAll(ctx *ExprTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExprTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelfExprTermContext struct {
	ExprTermContext
	selfExpr IExprTermContext
}

func NewSelfExprTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelfExprTermContext {
	var p = new(SelfExprTermContext)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *SelfExprTermContext) GetSelfExpr() IExprTermContext { return s.selfExpr }

func (s *SelfExprTermContext) SetSelfExpr(v IExprTermContext) { s.selfExpr = v }

func (s *SelfExprTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelfExprTermContext) ExprTerm() IExprTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *SelfExprTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterSelfExprTerm(s)
	}
}

func (s *SelfExprTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitSelfExprTerm(s)
	}
}

type BinaryExprTerm2Context struct {
	ExprTermContext
	lhs IExprTermContext
	op  IBinaryOpContext
	rhs IExprTermContext
}

func NewBinaryExprTerm2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExprTerm2Context {
	var p = new(BinaryExprTerm2Context)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *BinaryExprTerm2Context) GetLhs() IExprTermContext { return s.lhs }

func (s *BinaryExprTerm2Context) GetOp() IBinaryOpContext { return s.op }

func (s *BinaryExprTerm2Context) GetRhs() IExprTermContext { return s.rhs }

func (s *BinaryExprTerm2Context) SetLhs(v IExprTermContext) { s.lhs = v }

func (s *BinaryExprTerm2Context) SetOp(v IBinaryOpContext) { s.op = v }

func (s *BinaryExprTerm2Context) SetRhs(v IExprTermContext) { s.rhs = v }

func (s *BinaryExprTerm2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExprTerm2Context) AllExprTerm() []IExprTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprTermContext); ok {
			len++
		}
	}

	tst := make([]IExprTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprTermContext); ok {
			tst[i] = t.(IExprTermContext)
			i++
		}
	}

	return tst
}

func (s *BinaryExprTerm2Context) ExprTerm(i int) IExprTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *BinaryExprTerm2Context) BinaryOp() IBinaryOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryOpContext)
}

func (s *BinaryExprTerm2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterBinaryExprTerm2(s)
	}
}

func (s *BinaryExprTerm2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitBinaryExprTerm2(s)
	}
}

type UnaryExprTermContext struct {
	ExprTermContext
	op  IUnaryOpContext
	arg IExprTermContext
}

func NewUnaryExprTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExprTermContext {
	var p = new(UnaryExprTermContext)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *UnaryExprTermContext) GetOp() IUnaryOpContext { return s.op }

func (s *UnaryExprTermContext) GetArg() IExprTermContext { return s.arg }

func (s *UnaryExprTermContext) SetOp(v IUnaryOpContext) { s.op = v }

func (s *UnaryExprTermContext) SetArg(v IExprTermContext) { s.arg = v }

func (s *UnaryExprTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprTermContext) UnaryOp() IUnaryOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOpContext)
}

func (s *UnaryExprTermContext) ExprTerm() IExprTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *UnaryExprTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUnaryExprTerm(s)
	}
}

func (s *UnaryExprTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUnaryExprTerm(s)
	}
}

type ObjectAtomExprTermContext struct {
	ExprTermContext
	ident IObjectAtomContext
}

func NewObjectAtomExprTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectAtomExprTermContext {
	var p = new(ObjectAtomExprTermContext)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *ObjectAtomExprTermContext) GetIdent() IObjectAtomContext { return s.ident }

func (s *ObjectAtomExprTermContext) SetIdent(v IObjectAtomContext) { s.ident = v }

func (s *ObjectAtomExprTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectAtomExprTermContext) ObjectAtom() IObjectAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectAtomContext)
}

func (s *ObjectAtomExprTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterObjectAtomExprTerm(s)
	}
}

func (s *ObjectAtomExprTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitObjectAtomExprTerm(s)
	}
}

type UnaryExprTerm3Context struct {
	ExprTermContext
	op  IUnaryOpContext
	arg IExprTermContext
}

func NewUnaryExprTerm3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExprTerm3Context {
	var p = new(UnaryExprTerm3Context)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *UnaryExprTerm3Context) GetOp() IUnaryOpContext { return s.op }

func (s *UnaryExprTerm3Context) GetArg() IExprTermContext { return s.arg }

func (s *UnaryExprTerm3Context) SetOp(v IUnaryOpContext) { s.op = v }

func (s *UnaryExprTerm3Context) SetArg(v IExprTermContext) { s.arg = v }

func (s *UnaryExprTerm3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprTerm3Context) UnaryOp() IUnaryOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOpContext)
}

func (s *UnaryExprTerm3Context) ExprTerm() IExprTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *UnaryExprTerm3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUnaryExprTerm3(s)
	}
}

func (s *UnaryExprTerm3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUnaryExprTerm3(s)
	}
}

type UnaryExprTerm2Context struct {
	ExprTermContext
	op  IUnaryOpContext
	arg IExprTermContext
}

func NewUnaryExprTerm2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExprTerm2Context {
	var p = new(UnaryExprTerm2Context)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *UnaryExprTerm2Context) GetOp() IUnaryOpContext { return s.op }

func (s *UnaryExprTerm2Context) GetArg() IExprTermContext { return s.arg }

func (s *UnaryExprTerm2Context) SetOp(v IUnaryOpContext) { s.op = v }

func (s *UnaryExprTerm2Context) SetArg(v IExprTermContext) { s.arg = v }

func (s *UnaryExprTerm2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprTerm2Context) UnaryOp() IUnaryOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOpContext)
}

func (s *UnaryExprTerm2Context) ExprTerm() IExprTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *UnaryExprTerm2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUnaryExprTerm2(s)
	}
}

func (s *UnaryExprTerm2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUnaryExprTerm2(s)
	}
}

type BinaryExprTermContext struct {
	ExprTermContext
	lhs IExprTermContext
	op  IBinaryOpContext
	rhs IExprTermContext
}

func NewBinaryExprTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExprTermContext {
	var p = new(BinaryExprTermContext)

	InitEmptyExprTermContext(&p.ExprTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprTermContext))

	return p
}

func (s *BinaryExprTermContext) GetLhs() IExprTermContext { return s.lhs }

func (s *BinaryExprTermContext) GetOp() IBinaryOpContext { return s.op }

func (s *BinaryExprTermContext) GetRhs() IExprTermContext { return s.rhs }

func (s *BinaryExprTermContext) SetLhs(v IExprTermContext) { s.lhs = v }

func (s *BinaryExprTermContext) SetOp(v IBinaryOpContext) { s.op = v }

func (s *BinaryExprTermContext) SetRhs(v IExprTermContext) { s.rhs = v }

func (s *BinaryExprTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExprTermContext) AllExprTerm() []IExprTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprTermContext); ok {
			len++
		}
	}

	tst := make([]IExprTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprTermContext); ok {
			tst[i] = t.(IExprTermContext)
			i++
		}
	}

	return tst
}

func (s *BinaryExprTermContext) ExprTerm(i int) IExprTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprTermContext)
}

func (s *BinaryExprTermContext) BinaryOp() IBinaryOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryOpContext)
}

func (s *BinaryExprTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterBinaryExprTerm(s)
	}
}

func (s *BinaryExprTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitBinaryExprTerm(s)
	}
}

func (p *JetRuleParser) ExprTerm() (localctx IExprTermContext) {
	return p.exprTerm(0)
}

func (p *JetRuleParser) exprTerm(_p int) (localctx IExprTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 100
	p.EnterRecursionRule(localctx, 100, JetRuleParserRULE_exprTerm, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBinaryExprTerm2Context(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(767)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(768)

			var _x = p.exprTerm(0)

			localctx.(*BinaryExprTerm2Context).lhs = _x
		}
		{
			p.SetState(769)

			var _x = p.BinaryOp()

			localctx.(*BinaryExprTerm2Context).op = _x
		}
		{
			p.SetState(770)

			var _x = p.exprTerm(0)

			localctx.(*BinaryExprTerm2Context).rhs = _x
		}
		{
			p.SetState(771)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnaryExprTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(773)

			var _x = p.UnaryOp()

			localctx.(*UnaryExprTermContext).op = _x
		}
		{
			p.SetState(774)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(775)

			var _x = p.exprTerm(0)

			localctx.(*UnaryExprTermContext).arg = _x
		}
		{
			p.SetState(776)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewUnaryExprTerm2Context(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(778)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(779)

			var _x = p.UnaryOp()

			localctx.(*UnaryExprTerm2Context).op = _x
		}
		{
			p.SetState(780)

			var _x = p.exprTerm(0)

			localctx.(*UnaryExprTerm2Context).arg = _x
		}
		{
			p.SetState(781)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSelfExprTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(783)
			p.Match(JetRuleParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(784)

			var _x = p.exprTerm(0)

			localctx.(*SelfExprTermContext).selfExpr = _x
		}
		{
			p.SetState(785)
			p.Match(JetRuleParserT__10)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewUnaryExprTerm3Context(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(787)

			var _x = p.UnaryOp()

			localctx.(*UnaryExprTerm3Context).op = _x
		}
		{
			p.SetState(788)

			var _x = p.exprTerm(2)

			localctx.(*UnaryExprTerm3Context).arg = _x
		}

	case 6:
		localctx = NewObjectAtomExprTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(790)

			var _x = p.ObjectAtom()

			localctx.(*ObjectAtomExprTermContext).ident = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBinaryExprTermContext(p, NewExprTermContext(p, _parentctx, _parentState))
			localctx.(*BinaryExprTermContext).lhs = _prevctx

			p.PushNewRecursionContext(localctx, _startState, JetRuleParserRULE_exprTerm)
			p.SetState(793)

			if !(p.Precpred(p.GetParserRuleContext(), 7)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				goto errorExit
			}
			{
				p.SetState(794)

				var _x = p.BinaryOp()

				localctx.(*BinaryExprTermContext).op = _x
			}
			{
				p.SetState(795)

				var _x = p.exprTerm(8)

				localctx.(*BinaryExprTermContext).rhs = _x
			}

		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryOpContext is an interface to support dynamic dispatch.
type IBinaryOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GE() antlr.TerminalNode
	NE() antlr.TerminalNode
	REGEX2() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode
	OR() antlr.TerminalNode
	AND() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsBinaryOpContext differentiates from other interfaces.
	IsBinaryOpContext()
}

type BinaryOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryOpContext() *BinaryOpContext {
	var p = new(BinaryOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_binaryOp
	return p
}

func InitEmptyBinaryOpContext(p *BinaryOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_binaryOp
}

func (*BinaryOpContext) IsBinaryOpContext() {}

func NewBinaryOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryOpContext {
	var p = new(BinaryOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_binaryOp

	return p
}

func (s *BinaryOpContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryOpContext) PLUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserPLUS, 0)
}

func (s *BinaryOpContext) EQ() antlr.TerminalNode {
	return s.GetToken(JetRuleParserEQ, 0)
}

func (s *BinaryOpContext) LT() antlr.TerminalNode {
	return s.GetToken(JetRuleParserLT, 0)
}

func (s *BinaryOpContext) LE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserLE, 0)
}

func (s *BinaryOpContext) GT() antlr.TerminalNode {
	return s.GetToken(JetRuleParserGT, 0)
}

func (s *BinaryOpContext) GE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserGE, 0)
}

func (s *BinaryOpContext) NE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserNE, 0)
}

func (s *BinaryOpContext) REGEX2() antlr.TerminalNode {
	return s.GetToken(JetRuleParserREGEX2, 0)
}

func (s *BinaryOpContext) MINUS() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMINUS, 0)
}

func (s *BinaryOpContext) MUL() antlr.TerminalNode {
	return s.GetToken(JetRuleParserMUL, 0)
}

func (s *BinaryOpContext) DIV() antlr.TerminalNode {
	return s.GetToken(JetRuleParserDIV, 0)
}

func (s *BinaryOpContext) OR() antlr.TerminalNode {
	return s.GetToken(JetRuleParserOR, 0)
}

func (s *BinaryOpContext) AND() antlr.TerminalNode {
	return s.GetToken(JetRuleParserAND, 0)
}

func (s *BinaryOpContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, 0)
}

func (s *BinaryOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterBinaryOp(s)
	}
}

func (s *BinaryOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitBinaryOp(s)
	}
}

func (p *JetRuleParser) BinaryOp() (localctx IBinaryOpContext) {
	localctx = NewBinaryOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, JetRuleParserRULE_binaryOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-50)) & ^0x3f) == 0 && ((int64(1)<<(_la-50))&40959) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryOpContext is an interface to support dynamic dispatch.
type IUnaryOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	TOTEXT() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsUnaryOpContext differentiates from other interfaces.
	IsUnaryOpContext()
}

type UnaryOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOpContext() *UnaryOpContext {
	var p = new(UnaryOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_unaryOp
	return p
}

func InitEmptyUnaryOpContext(p *UnaryOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_unaryOp
}

func (*UnaryOpContext) IsUnaryOpContext() {}

func NewUnaryOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOpContext {
	var p = new(UnaryOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_unaryOp

	return p
}

func (s *UnaryOpContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOpContext) NOT() antlr.TerminalNode {
	return s.GetToken(JetRuleParserNOT, 0)
}

func (s *UnaryOpContext) TOTEXT() antlr.TerminalNode {
	return s.GetToken(JetRuleParserTOTEXT, 0)
}

func (s *UnaryOpContext) Identifier() antlr.TerminalNode {
	return s.GetToken(JetRuleParserIdentifier, 0)
}

func (s *UnaryOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterUnaryOp(s)
	}
}

func (s *UnaryOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitUnaryOp(s)
	}
}

func (p *JetRuleParser) UnaryOp() (localctx IUnaryOpContext) {
	localctx = NewUnaryOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, JetRuleParserRULE_unaryOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(804)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-48)) & ^0x3f) == 0 && ((int64(1)<<(_la-48))&131075) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITripleStmtContext is an interface to support dynamic dispatch.
type ITripleStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetS returns the s rule contexts.
	GetS() IAtomContext

	// GetP returns the p rule contexts.
	GetP() IAtomContext

	// GetO returns the o rule contexts.
	GetO() IObjectAtomContext

	// SetS sets the s rule contexts.
	SetS(IAtomContext)

	// SetP sets the p rule contexts.
	SetP(IAtomContext)

	// SetO sets the o rule contexts.
	SetO(IObjectAtomContext)

	// Getter signatures
	TRIPLE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	AllAtom() []IAtomContext
	Atom(i int) IAtomContext
	ObjectAtom() IObjectAtomContext

	// IsTripleStmtContext differentiates from other interfaces.
	IsTripleStmtContext()
}

type TripleStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	s      IAtomContext
	p      IAtomContext
	o      IObjectAtomContext
}

func NewEmptyTripleStmtContext() *TripleStmtContext {
	var p = new(TripleStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_tripleStmt
	return p
}

func InitEmptyTripleStmtContext(p *TripleStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = JetRuleParserRULE_tripleStmt
}

func (*TripleStmtContext) IsTripleStmtContext() {}

func NewTripleStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TripleStmtContext {
	var p = new(TripleStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = JetRuleParserRULE_tripleStmt

	return p
}

func (s *TripleStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TripleStmtContext) GetS() IAtomContext { return s.s }

func (s *TripleStmtContext) GetP() IAtomContext { return s.p }

func (s *TripleStmtContext) GetO() IObjectAtomContext { return s.o }

func (s *TripleStmtContext) SetS(v IAtomContext) { s.s = v }

func (s *TripleStmtContext) SetP(v IAtomContext) { s.p = v }

func (s *TripleStmtContext) SetO(v IObjectAtomContext) { s.o = v }

func (s *TripleStmtContext) TRIPLE() antlr.TerminalNode {
	return s.GetToken(JetRuleParserTRIPLE, 0)
}

func (s *TripleStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(JetRuleParserSEMICOLON, 0)
}

func (s *TripleStmtContext) AllAtom() []IAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAtomContext); ok {
			len++
		}
	}

	tst := make([]IAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAtomContext); ok {
			tst[i] = t.(IAtomContext)
			i++
		}
	}

	return tst
}

func (s *TripleStmtContext) Atom(i int) IAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *TripleStmtContext) ObjectAtom() IObjectAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectAtomContext)
}

func (s *TripleStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TripleStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TripleStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.EnterTripleStmt(s)
	}
}

func (s *TripleStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(JetRuleListener); ok {
		listenerT.ExitTripleStmt(s)
	}
}

func (p *JetRuleParser) TripleStmt() (localctx ITripleStmtContext) {
	localctx = NewTripleStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, JetRuleParserRULE_tripleStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.Match(JetRuleParserTRIPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(807)
		p.Match(JetRuleParserT__9)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(808)

		var _x = p.Atom()

		localctx.(*TripleStmtContext).s = _x
	}
	{
		p.SetState(809)
		p.Match(JetRuleParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(810)

		var _x = p.Atom()

		localctx.(*TripleStmtContext).p = _x
	}
	{
		p.SetState(811)
		p.Match(JetRuleParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(812)

		var _x = p.ObjectAtom()

		localctx.(*TripleStmtContext).o = _x
	}
	{
		p.SetState(813)
		p.Match(JetRuleParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(814)
		p.Match(JetRuleParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *JetRuleParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 50:
		var t *ExprTermContext = nil
		if localctx != nil {
			t = localctx.(*ExprTermContext)
		}
		return p.ExprTerm_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *JetRuleParser) ExprTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
